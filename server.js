const http = require('http');
const express = require('express');
const app = express();
app.get("/", (request, response) => {
  response.sendStatus(200);
});
app.listen(process.env.PORT);
setInterval(() => {
  http.get(`http://arabdark.glitch.me/`);
}, 280000);

const Discord = require('discord.js');  
const client = new Discord.Client();
const moment = require('moment');
const zalgo = require('zalgolize');  
const math = require('math-expression-evaluator');   
const figlet = require('figlet');   
const fs = require('fs');  
const ms = require('ms');  
const prefix = '.'
const Gamedig = require('gamedig');
client.on('ready', () => {
console.log('Ready!');
});
client.on("message", async message => {
  if(message.author.bot) return;
  if(message.content.indexOf(prefix) !== 0) return;
  const args = message.content.slice(prefix.length).trim().split(/ +/g);
  const command = args.shift().toLowerCase();
 
  if(command === "mta") {
    Gamedig.query({
      type: 'mtasa', // multi theft auto
      host: '178.32.125.24', // ip adrsese
      port: '22003' // default ir 22003
      }).then((state) => {
        let mEmbed = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setTitle('Multi Theft Auto')
        .setDescription(state['name'])
        .addField('Status', 'Online', true)
        .addField('Players', state['raw']['numplayers'] + ' no ' + state['maxplayers'], true)
        .addField('Map', state['map'], true)
        .addField('Version', state['raw']['version'], true)
        .addField('Game Type', state['raw']['gametype'], true)
        .addField('Connect', state['connect'], true)
        .addField('Password Stats', state['password'], true)
        .addField('test', state['raw']['ilter'])
        .setTimestamp()
        .setFooter('Arab Dark Gaming System.', + `${message.guild.iconURL}`)
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/699912650368483398/Sin-titulo-1.gif')
        message.channel.send({embed: mEmbed});
      }).catch((error) => {
      let eeEmbed = new Discord.RichEmbed()
      .setColor('RED')
      .setTitle("Server Off - Ø§Ù„Ø³ÙŠØ±ÙØ± ØºÙŠØ± Ø´ØºØ§Ù„")
      message.channel.send({embed: eeEmbed});
      });
    } else if(command === "mtaplayers123231") {
      Gamedig.query({
        type: 'mtasa', // multi theft auto
        host: '195.3.145.36', // ip adrsese
        port: '22003' // default ir 22003
        }).then((state) => {
          if (state['raw']['numplayers'] === 0){
            message.reply('PaÅ¡laik serverÄ« "' + state['name'] + '" nav aktÄ«vu spÄ“lÄ“tÄju ');
           
          } else {
            message.reply('PaÅ¡laik serverÄ« "' + state['name'] + '" pieslÄ“guÅ¡ies ' + state['raw']['numplayers'] + ' spÄ“lÄ“tÄji');
          }
        }).catch((error) => {
          message.reply("Serveris ir izslÄ“gts, vai arÄ« nevar atrast serveri!");
        });
      };
 
  // cs 1.6 serveris
 
  if(command === "cs") {
    Gamedig.query({
      type: 'cs16', // counter-strike 1.6
      host: 'cs.kick.lv', // ip adrsese
      port: '27015' // default ir 27015
      }).then((state) => {
        let cs16Embed = new Discord.RichEmbed()
        .setColor('#0099ff')
        .setTitle(state['name'])
        .setDescription(state['raw']['game'])
        .addField('Statuss', 'Online', true)
        .addField('SpÄ“lÄ“tÄji', state['raw']['numplayers'] + ' no ' + state['maxplayers'], true)
        .addField('Karte', state['map'], true)
        .addField('Time Left', state['raw']['rules']['amx_timeleft'], true)
        .addField('Protokols', state['raw']['protocol'], true)
        .addField('Adrese', state['connect'], true)
        .setTimestamp()
        .setFooter('Arab Dark Gaming System.', + `${message.guild.iconURL}`)
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
        message.channel.send({embed: cs16Embed});
        console.log(state);
      }).catch((error) => {
        message.reply("Counter-Strike 1.6 serveris ir izslÄ“gts!");
      });
    } else if(command === "csplayers") {
      Gamedig.query({
        type: 'cs16', // counter-strike 1.6
        host: 'cs.kick.lv', // ip adrsese
        port: '27015' // default ir 27015
        }).then((state) => {
          if (state['raw']['numplayers'] === 0){
            message.reply('PaÅ¡laik serverÄ« "' + state['name'] + '" nav aktÄ«vu spÄ“lÄ“tÄju ');
           
          } else {
            message.reply('PaÅ¡laik serverÄ« "' + state['name'] + '" pieslÄ“guÅ¡ies ' + state['raw']['numplayers'] + ' spÄ“lÄ“tÄji');
            // var arrayLength = state['players'].length;
            // for (var i = 0; i < arrayLength; i++) {
            //   message.channel.send(
            //     state['players'][i]['name']
            //     );
            // }  // jataisa lai parada ka embed
          }
        }).catch((error) => {
          message.reply("Serveris ir izslÄ“gts, vai arÄ« nevar atrast serveri!");
        });
      };
 
 
 
});
let data = JSON.parse(fs.readFileSync("./data.json", "utf8"));
client.on("message", async message => {
  var prefix = "#";
  if(message.content.startsWith(prefix + "mkmkmkmkmmembers")) {
  var args = message.content.split(" ").slice(1)
  if(!args[0] || !args[1] ) return message.channel.send("> **Use:** " + prefix + "set RoleID ChannelID ");
    let ro = message.guild.roles.get(args[0]);
    if (!ro) return message.channel.send("> I can't find this channel!")
var ch = client.channels.get(args[1])
    if (!ch) return message.channel.send("> I can't find this role!") 
     data = {role:args[0], channel:args[1]}
    fs.writeFile('./data.json', JSON.stringify(data, null, 4), function(err) {if(err) console.log(err)});
     message.channel.send("> Done..:white_check_mark:")  
  }
})
client.on('guildMemberUpdate', member => {
    if(!data.role) return console.log("Error .")
  var role = member.guild.members.filter (m => m.roles.get(data.role))
  member.guild.channels.get(data.channel).setName(`Members: [${role.size}]`)
 });
let data2 = JSON.parse(fs.readFileSync("./data2.json", "utf8"));
client.on("message", async message => {
  var prefix = "#";
  if(message.content.startsWith(prefix + "mkmkmkmkmkmkmkmkmbots")) {
  var args = message.content.split(" ").slice(1)
  if(!args[0] || !args[1] ) return message.channel.send("> **Use:** " + prefix + "set RoleID ChannelID ");
    let ro = message.guild.roles.get(args[0]);
    if (!ro) return message.channel.send("> I can't find this channel!")
var ch = client.channels.get(args[1])
    if (!ch) return message.channel.send("> I can't find this role!") 
     data2 = {role:args[0], channel:args[1]}
    fs.writeFile('./data2.json', JSON.stringify(data2, null, 4), function(err) {if(err) console.log(err)});
     message.channel.send("> Done..:white_check_mark:")  
  }
})
client.on('guildMemberUpdate', member => {
    if(!data2.role) return console.log("Error .")
  var role = member.guild.members.filter (m => m.roles.get(data2.role))
  member.guild.channels.get(data2.channel).setName(`Bots: [${role.size}]`)
 });
///////////////////////////////////////////////////////////////////////////////////
const antispam = JSON.parse(fs.readFileSync("./antispam.json", "utf8"));

client.on("message", async message => {
  if (antispam[message.author.id] == undefined) {
    antispam[message.author.id] = {
    lastmessage: "none"
    };
    fs.writeFile("./antispam.json", JSON.stringify(antispam), function(err) {
      if (err) throw err;
    });
  }else  if (antispam[message.guild.id] == undefined) {
    antispam[message.guild.id] = {
    onoff: "off"
    };
    fs.writeFile("./antispam.json", JSON.stringify(antispam), function(err) {
      if (err) throw err;
    });
  }
  let args = message.content.split(" ");
  let command = args[0]
    if(command === prefix + "antispam"){
      if(!args[1])return message.channel.send("**Error | Use `antispam on/off`**");
    if(args[1] === "on"){
            message.channel.send("**Done Sir Anti Spam Changed To ON**")
      antispam[message.guild.id].onoff = "on";
      fs.writeFile("./antispam.json", JSON.stringify(antispam), function(
        err
      ) {
        if (err) throw err;
      });
    }else if(args[1] === "off"){
      antispam[message.guild.id].onoff = "off";
      fs.writeFile("./antispam.json", JSON.stringify(antispam), function(
        err
      ) {
        if (err) throw err;
      });
      message.channel.send("**Done Sir Anti Spam Changed To OFF**")
    }
  }
});

client.on("message", async message => {
  if (antispam[message.author.id] == undefined) {
    antispam[message.author.id] = {
    lastmessage: "none"
    };
    fs.writeFile("./antispam.json", JSON.stringify(antispam), function(err) {
      if (err) throw err;
    });
  }else  if (antispam[message.guild.id] == undefined) {
    antispam[message.guild.id] = {
    onoff: "off"
    };
    fs.writeFile("./antispam.json", JSON.stringify(antispam), function(err) {
      if (err) throw err;
    });
  }else if(antispam[message.author.id].lastmessage === "none") {
    return;
  }else if(antispam[message.guild.id].onoff === "off"){
    return;
  }else if(antispam[message.author.id].lastmessage === message.content){
    return message.delete();
  }

  antispam[message.author.id].lastmessage = message.content;
  fs.writeFile("./antispam.json", JSON.stringify(antispam), function(
    err
  ) {
    if (err) throw err;
  });

});
client.on('message', message => {
if (!message.content.startsWith(prefix)) return;
	let command = message.content.split(" ")[0];
	 command = command.slice(prefix.length);
	let args = message.content.split(" ").slice(1);
	if (command == "mute") {
		if (!message.channel.guild) return;
		if(!message.guild.member(message.author).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª !! ").then(msg => msg.delete(5000));
		if(!message.guild.member(client.user).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù„Ø¨ÙˆØª Ù„Ø§ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª ").then(msg => msg.delete(5000));;
		let user = message.mentions.users.first();
		let muteRole = message.guild.roles.find("name", "Muted");
		if (!muteRole) return message.reply("** Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØªØ¨Ø© Ø§Ù„Ù…ÙŠÙˆØª 'Muted' **").then(msg => {msg.delete(5000)});
		if (message.mentions.users.size < 1) return message.reply('** ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‹ **').then(msg => {msg.delete(5000)});
		let reason = message.content.split(" ").slice(2).join(" ");
		message.guild.member(user).addRole(muteRole);
		const muteembed = new Discord.RichEmbed()
		.setColor("RANDOM")
		.setAuthor(`Muted!`, user.displayAvatarURL)
		.setThumbnail(user.displayAvatarURL)
		.addField("**:busts_in_silhouette:  Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**",  '**[ ' + `${user.tag}` + ' ]**',true)
		.addField("**:hammer:  ØªÙ… Ø¨ÙˆØ§Ø³Ø·Ø© **", '**[ ' + `${message.author.tag}` + ' ]**',true)
		.addField("**:book:  Ø§Ù„Ø³Ø¨Ø¨**", '**[ ' + `${reason}` + ' ]**',true)
		.addField("User", user, true)
        .setFooter('Arab Dark Gaming System.', + `${message.guild.iconURL}`)
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
		message.channel.send({embed : muteembed});
		var muteembeddm = new Discord.RichEmbed()
		.setAuthor(`Muted!`, user.displayAvatarURL)
		.setDescription(`      
${user} Ø§Ù†Øª Ù…Ø¹Ø§Ù‚Ø¨ Ø¨Ù…ÙŠÙˆØª ÙƒØªØ§Ø¨ÙŠ Ø¨Ø³Ø¨Ø¨ Ù…Ø®Ø§Ù„ÙØ© Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ†
${message.author.tag} ØªÙ…Øª Ù…Ø¹Ø§Ù‚Ø¨ØªÙƒ Ø¨ÙˆØ§Ø³Ø·Ø©
[ ${reason} ] : Ø§Ù„Ø³Ø¨Ø¨
Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ ØªÙƒÙ„Ù… Ù…Ø¹ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ†
`)
		.setFooter(`ÙÙŠ Ø³ÙŠØ±ÙØ± : ${message.guild.name}`)
		.setColor("RANDOM")
    .setFooter(`${message.guild.iconURL}`, + 'Arab Dark Gaming System.')
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
	user.send( muteembeddm);
  }
if(command === `unmute`) {
  if(!message.member.hasPermission("MANAGE_MESSAGES")) return message.channel.sendMessage("**Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ÙÙƒ Ø¹Ù† Ø§Ù„Ø´Ø®Øµ Ù…ÙŠÙˆØª**:x: ").then(m => m.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_MESSAGES")) return message.reply("**Ù…Ø§ Ø¹Ù†Ø¯ÙŠ Ø¨Ø±Ù…Ø´Ù†**").then(msg => msg.delete(6000))

  let toMute = message.guild.member(message.mentions.users.first()) || message.guild.members.get(args[0]);
  if(!toMute) return message.channel.sendMessage("**Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø£ÙˆÙ„Ø§Ù‘**:x: ");

  let role = message.guild.roles.find (r => r.name === "Muted");
  
  if(!role || !toMute.roles.has(role.id)) return message.channel.sendMessage("**Ù„Ù… ÙŠØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ù‡Ø°Ù‡ Ø´Ø®Øµ Ù…ÙŠÙˆØª Ù…Ù† Ø§Ù„Ø£Ø³Ø§Ø³**:x:")

  message.channel.sendMessage("**Ù„Ù‚Ø¯ ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù† Ø´Ø®Øµ Ø¨Ù†Ø¬Ø§Ø­**:white_check_mark:");

  return;

  }

});

 
client.on('message', message => {
  if (message.author.x5bz) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);
});
/////////////
client.on('message', message => { 
  if(message.content.startsWith(prefix + "warn")) {
    if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply(`You Don't Have Permission`);
     let user = message.mentions.users.first();
         if(!user) return message.reply('**Mention The User Please !**').then(message => message.delete(4500));;
     let reason = message.content.split(' ').slice(2);

         if(message.guild.member(user).hasPermission("ADMINISTRATOR")) return message.reply(`**You Can't Warn This User**`).then(message => message.delete(5000));;
     let embed = new Discord.RichEmbed()
     .setTitle(':warning: **You Were warned!')
     .addField(reason)
    .setFooter(`${message.guild.iconURL}`, + 'Arab Dark Gaming System.')
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
     user.sendEmbed(embed)
     message.channel.send(`This User Has Ben Warned!`);

  }

});
///////////////////////////
client.on('message', message => {
if (message.author.bot) return;
  let args = message.content.split(" ");
      // By Alpha Codes - AboKhalil 26/7/2019
  let command = args[0];
 
  let user = message.mentions.users.first();
   
  let reasonkick = message.content.split(" ").slice(2).join(" ");
 
  if (command == prefix + "kick") {
 
    if(!message.channel.guild){
    message.channel.send("**Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¹Ù…Ø§Ù„ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙÙŠ Ø§Ù„Ø®Ø§Øµ**");
}
    if(!message.guild.member(message.author).hasPermission("KICK_MEMBERS")) {
        message.channel.send("**ÙŠØ¬Ø¨ Ø§Ù† ÙŠÙƒÙˆÙ† Ù„Ø¯ÙŠÙƒ Ø®Ø§ØµÙŠØ© `KICK_MEMBERS`**");
    }
    if(!message.guild.member(client.user).hasPermission("KICK_MEMBERS")) {
        message.channel.send("**Ø§Ù„Ø¨ÙˆØª Ù„Ø§ ÙŠÙ…ØªÙ„Ùƒ Ø®Ø§ØµÙŠØ© `KICK_MEMBERS`**");
    }
    if (!user) {
         let kickembed = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setTitle("Kick System")
        .setDescription('.kick @user Reason')
  .setFooter('Arab Dark Gaming System.')
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
        message.channel.send({embed: kickembed});
    }else if (!reasonkick) {
        message.channel.send("**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø¥Ø¯Ø±Ø§Ø¬ Ø³Ø¨Ø¨ Ø§Ù„Ø­Ø¸Ø±**");
    } else if (message.guild.member(user).hasPermission("KICK_MEMBERS")){
    message.channel.send("**Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø·Ø±Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ø´Ø®Øµ , ÙÙ‡Ùˆ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©**");
    } else {
 
 
    message.guild.member(user).kick()
    message.channel.send("**The Member Was Kicked **" + user.tag + " **By** : " + message.author.tag);
    message.channel.send("**Reason : __" + reasonkick + "__**");
   
    user.send("**You are Kicked By** : " + message.author.tag);
    user.send("**Reason : __" + reasonkick + "__**");
    }
 }
 // By Alpha Codes - AboKhalil 26/7/2019
});
////////////////////////////////////
client.on("message",async message => {
if(message.content === '.vote'){//Ø§Ù„Ø§Ù…Ø±
if(!message.member.roles.some(r=>["manager","test1"].includes(r.name)) ) return; // Ø§Ù„Ø±ØªØ¨ Ø§Ù„ÙŠ ÙŠÙ…Ø¯ÙŠÙ‡Ø§ ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø§Ù…Ø± ÙŠÙ…Ø¯ÙŠÙƒ ØªØ®Ù„ÙŠÙ‡Ø§ Ø¨ Ø¨Ø±Ù…Ø´Ù†
 
    let go1; //Ø§Ù†Ø´Ø§Ø¡ Ù…ØªØºÙŠØ± go1
      let filter = m => m.author.id === message.author.id // (ØªØ¹Ø±ÙŠÙ Ø§Ù„ÙÙ„ØªØ± (Ø§Ù„Ø´Ø®Øµ Ø§Ù„ÙŠ ÙŠÙ…Ø¯ÙŠÙ‡ ÙŠØ±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¨ÙˆØª ÙŠÙƒÙˆÙ† Ø¨Ø³ Ø§Ù„ÙƒØ§ØªØ¨
     
     
 
      await message.channel.send("** Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ù„ØªØµÙˆÙŠØª ÙÙŠÙ‡ Ø¨Ø¯ÙˆÙ† Ù…Ù†Ø´Ù† ... âœ**").then(go => {
      message.channel.awaitMessages(filter, { time: 90000, max: 1             // Ø´Ø±ÙˆØ· Ø§Ù„Ø§Ù†ØªØ¶Ø§Ø± Ù…Ù† Ø¨ÙŠÙ†Ù‡Ø§ Ø§Ù„ÙÙ„ØªØ± ÙŠÙƒÙˆÙ† Ø¨Ø³ Ø§Ù„ÙƒØ§ØªØ¨ Ø§Ù„ÙŠ ÙŠØ±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª                        
})
     .then(go3 => { // Ø§Ø°Ø§ ØªØ­Ù‚Ù‚Ø© Ø§Ù„Ø´Ø±ÙˆØ· Ø§Ù„ÙŠ ÙÙˆÙ‚
       go1 = go3.first().content; // ÙŠØ¹Ø·ÙŠ Ù‚ÙŠÙ…Ø© Ù„Ù…ØªØºÙŠØ± go1
        go3.first().delete(); // ÙŠØ­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©
     
let go2; // Ø§Ù†Ø´Ø§Ø¡ Ù…ØªØºÙŠØ± go2
       
 go.edit("**Ø§ÙƒØªØ¨ Ø§Ù„Ø´ÙŠØ¡ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ù„ØªØµÙˆÙŠØª Ø¹Ù„ÙŠÙ‡ ... âœ **").then(go => {
  message.channel.awaitMessages(filter, { time: 90000, max: 1 }) // Ø´Ø±ÙˆØ· Ø§Ù„Ø§Ù†ØªØ¶Ø§Ø± Ù…Ù† Ø¨ÙŠÙ†Ù‡Ø§ Ø§Ù„ÙÙ„ØªØ± Ø§Ù„ÙŠ Ø´Ø±Ø­Ù†Ø§Ù‡ ÙÙˆÙ‚ Ùˆ ÙˆÙ‚Øª Ø§Ù„Ø§Ù†ØªØ¶Ø§Ø±
 
     .then(go3 => { // Ø§Ø°Ø§ ØªØ­Ù‚Ù‚ Ø§Ù„Ø´Ø±ÙˆØ·Ø© Ø§Ù„ÙŠ ÙÙˆÙ‚
       go2 = go3.first().content; // ÙŠØ¹Ø·ÙŠ Ù‚ÙŠÙ…Ø© Ù„Ù„Ù…ØªØºÙŠØ± go2
        go3.first().delete(); // ÙŠØ­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©
  let room = message.guild.channels.find("name",go1)
  if(!room) return message.reply("**Ø§Ù„Ø±ÙˆÙ… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø§Ùˆ Ø§Ù†Ùƒ Ù‚Ù…Øª Ø¨Ù…Ù†Ø´Ù†Ø© Ø§Ù„Ø±ÙˆÙ…**") // Ø§Ø°Ø§ Ù…Ø§ÙƒØ§Ù† ÙÙŠÙ‡ Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ÙƒØªØ¨Ù‡ Ø§Ù„Ø´Ø®Øµ Ø§ÙˆÙ„ ÙŠÙ‚ÙˆÙ„Ù‡ Ù…Ø§ÙÙŠ
 go.edit(" ğŸ›¡ **ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„.**").then(go => { //  ÙŠØ¹Ø¯Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙˆÙŠÙ‚ÙˆÙ„ ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„ ÙˆÙŠØ±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø±ÙˆÙ… Ø§Ù„Ù…Ø­Ø¯Ø¯
 let embed2 = new Discord.RichEmbed()
          .setColor("#79cbfa")
          .setDescription(`
          Yes ! 1âƒ£
           No ! 2âƒ£`)
          .setTimestamp()
  room.send(`${go2}`)
  room.send(embed2).then(go4 => {
  go4.react('2âƒ£')
  go4.react('1âƒ£')
  })
  })
})
  })
})
  })
           
     
 
     
 
     
           
}
});
//////////////////////
let rab6 = JSON.parse(fs.readFileSync('./rab6.json' , 'utf8'));
client.on('message', message => {
    if(message.content.startsWith(prefix + "togglink")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
        if(!rab6[message.guild.id]) rab6[message.guild.id] = {
          onoff: 'Off'
        }
          if(rab6[message.guild.id].onoff === 'Off') return [message.channel.send(`**âœ… The Invite Link Cmd Is __ğğ__ !**`), rab6[message.guild.id].onoff = 'On']
          if(rab6[message.guild.id].onoff === 'On') return [message.channel.send(`**â›” The Invite Link Cmd Is __ğğ…ğ…__ !**`), rab6[message.guild.id].onoff = 'Off']
          fs.writeFile("./rab6.json", JSON.stringify(rab6), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            });
          }
          
        })
        const coolDown = new Set();
client.on('message', message => {
if (message.content.startsWith("inv")) {
if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
if(!rab6[message.guild.id]) rab6[message.guild.id] = {
onoff: 'Off'
}
if(rab6[message.guild.id].onoff === 'Off') return;
if(coolDown.has(message.author.id)) return message.channel.send(`**â± | ${message.author.username}, your invite ğŸ’´ link refreshes in ``1 Day``.**`);
message.channel.createInvite({
thing: true,
maxUses: 5,
maxAge: 86400
}).then(invite =>
message.author.sendMessage(invite.url)
)
message.channel.send("** ïº—ï»¢ ïºïº­ïº³ïºï» ïºï»Ÿïº®ïºïº‘ï»‚ ïº‘ïº®ïº³ïºï»Ÿïº” ïº§ïºïº»ïº” **") .then(() => {
coolDown.add(message.author.id);
});
message.author.send(`** ï»£ïºªïº“ ïºï»Ÿïº®ïºïº‘ï»‚ : ï»³Ù€ï»®ï»¡
ï»‹ïºªïº© ïºïº³ïº˜ïº¨ïºªïºï»£ïºïº• ïºï»Ÿïº®ïºïº‘ï»‚ : 5 **`)
}
setTimeout(() => {
coolDown.remove(message.author.id);
},86400000);
});
////////////////////
client.on("message", async message => {
    if(message.content.startsWith(prefix + "banlist")) {
        if(!message.guild) return;
                if(!message.member.hasPermission('BAN_MEMBERS')) return message.channel.send('**Sorry But You Dont Have Permission** `BAN_MEMBERS`' );
        message.guild.fetchBans()
        .then(bans => {
            let b = bans.size;
            let bb = bans.map(a => `${a}`).join(" - ");
         let ebanembed = new Discord.RichEmbed()
        .setColor('RADNIM')
        .setTitle("Ban List System")
        .addField('BanList', + `${b}`)
        .addField('BanMaps', + `${bb}`)
  .setFooter('Arab Dark Gaming System.')
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
        message.channel.send({embed: ebanembed});
        });
    }
});
/////////////////
client.on('message', message => { /// edit fox
      if(message.content ===  ".close") {
      if(!message.channel.guild) return;
      if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ø¯Ù…Ù† :x:');
             message.channel.overwritePermissions(message.guild.id, {
             READ_MESSAGES: false
 })
              message.channel.send('ØªÙ… Ø§Ø®ÙØ§Ø¡ Ø§Ù„Ø´Ø§Øª ! :white_check_mark:  ') ///edit fox
 }
});


client.on('message', message => {
      if(message.content === ".open") {
      if(!message.channel.guild) return;
      if(!message.member.hasPermission('ADMINISTRATOR')) return message.reply('Ù„ÙŠØ³Øª Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ø¯Ù…Ù† :x:');
             message.channel.overwritePermissions(message.guild.id, {
             READ_MESSAGES: true
 })
              message.channel.send('ØªÙ… Ø§Ø¸Ù‡Ø§Ø± Ø§Ù„Ø´Ø§Øª :white_check_mark: ')
 }
});
client.on('message', message => {
    if(message.author.bot) return;
    if(message.channel.type == "dm") return;

    var messages = message.content.split(" ").slice(1);

    let args = messages.slice(1); 

    var prefix = ".";
    if(message.content.startsWith(prefix+'report')){
        let msg = message;


        if(message.guild.member(message.author).roles.get(msg.guild.roles.find(role => role.name === `banned_report`))) return message.reply('**Ù„Ù‚Ø¯ ØªÙ… Ø­Ø¸Ø±Ùƒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø¨Ù„Ø§Øº Ø§Ø­Ø¯**').then(m => {m.delete(3000)}); //Ù„Ùˆ Ø­Ø¯ Ø¹Ù†Ø¯Ù‡ Ù‡Ù„ Ø±ØªØ¨Ø© Ù…Ø§ Ø±Ø­ ÙŠÙ‚Ø¯Ø± ÙŠØ³ÙˆÙŠ Ø±ÙŠØ¨ÙˆØ±Øª 

        var reports_channel = message.guild.channels.find('name', 'reports') // Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ØªØ¬ÙŠÙ‡ Ø§Ù„Ø±ÙŠØ¨ÙˆØ±ØªØ§Øª

        if(!reports_channel) return message.reply('**I cant find reports room.**').then(m => {m.delete(3000)});
        
        var mention = message.mentions.users.first();
        
        if(!mention) return message.reply('**Please, mention a member.**').then(m => {m.delete(3000)});

        if(mention.id == message.author.id) return message.reply('**You cant report yourself**').then(m => {m.delete(3000)});
        
        if(message.guild.member(mention).hasPermission("MANAGE_MESSAGES")) return message.reply('**You cant report this user.**').then(m => {m.delete(3000)}) //Ù„Ùˆ Ø´Ø®Øµ Ø¹Ù†Ø¯Ù‡ Ù‡Ù„ Ø¨Ø±Ù…Ø´Ù† Ù…Ø§Ø­Ø¯ Ø±Ø­ ÙŠÙ‚Ø¯Ø± ÙŠØ³ÙˆÙŠÙ„Ù‡ Ø±ÙŠØ¨ÙˆØ±Øª
        
        if(mention.id == message.guild.owner.id) return message.reply('**You cant report the owner.**').then(m => {m.delete(3000)});


        var reason = args.join(" ");

        if(!reason) return message.reply('**Please, specify a reason.**').then(m => {m.delete(3000)});
        var embed = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setTitle(`NEW REPORT`)
        .setThumbnail(message.author.avatarURL)
        .addField('**Reporter Name: **', `<@${message.author.id}> ID [ ${message.author.id} ]`, true)
        .addField('**ReportedUser Name: **', `${mention} ID [ ${mention.id} ]`, true)
        .addField('**Time** ', `[ ${moment(message.createdAt).format('D/MM/YYYY h:mm a')} ]`, true)
        .addField('**reason: **', `[ ${reason} ]`, true)
        .addField('**Channel: **', `${message.channel}`, true)
        .setFooter('Arab Dark Gaming System.')
        .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
        reports_channel.send(embed)
        message.channel.send('**ØªÙ… Ø§Ù„Ø¨Ù„Ø§Øº, Ù†Ø´ÙƒØ±Ùƒ Ø¹Ù„Ù‰  Ù…Ø³Ø§Ø¹Ø¯ØªÙ†Ø§**').then(message => {message.delete(3000)});
    }
});
/////////////////////////
   client.on('message', message => {
    const prefix = '.'
var args = message.content.split(" ").slice(1);    
if(message.content.startsWith(prefix + 'id')) {
var year = message.author.createdAt.getFullYear()
var month = message.author.createdAt.getMonth()
var day = message.author.createdAt.getDate()
var men = message.mentions.users.first();  
let args = message.content.split(' ').slice(1).join(' ');
if (args == '') {
var z = message.author;
}else {
var z = message.mentions.users.first();
}

let d = z.createdAt;          
let n = d.toLocaleString();   
let x;                       
let y;                        

if (z.presence.game !== null) {
y = `${z.presence.game.name}`;
} else {
y = "Not Playing....";
}
let embed = new Discord.RichEmbed()
.setColor('RANDOM')
.addField('Name :',`**<@` + `${z.id}` + `>**`, true)
.addField('ID :', "**"+ `${z.id}` +"**",true)
.addField('Playing :','**'+y+'**' , true)
.addField('Discrim :',"**#" +  `${z.discriminator}**`,true)
.addField('**Created At**', message.author.createdAt.toLocaleString())
.addField("**Joined At**", message.member.joinedAt.toLocaleString())    

.setThumbnail(`${z.avatarURL}`)
.setFooter(message.author.username, message.author.avatarURL)

message.channel.send({embed});
    if (!message) return message.reply('**Ø¶Ø¹ Ø§Ù„Ù…ÙŠÙ†Ø´Ø§Ù† Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­  âŒ **').catch(console.error);

}

});
//////////////////////
client.on('message', function(msg) {
    if(msg.content.startsWith (prefix  + 'server')) {
      let embed = new Discord.RichEmbed()
      .setColor('RANDOM')
      .setThumbnail(msg.guild.iconURL)
      .setTitle(`__**ServerInfo**__`)
      .addField('**Ø§Ø³Ù… Ø§Ù„Ø³ÙŠØ±ÙØ±**',`[** __${msg.guild.name}__ **]`,true)
      .addField('**Ù†ÙˆØ¹ Ø§Ù„Ø³ÙŠØ±ÙØ±**',`[** __${msg.guild.region}__ **]`,true)
      .addField('**Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡**',`[** __${msg.guild.memberCount}__ **]`,true)
      .addField('**Ø¹Ø¯Ø¯ Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ†**',`[** __${msg.guild.memberCount - msg.guild.members.filter(m => m.user.bot).size}__ **]`,true)
      .addField('**Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ÙˆØªØ§Øª**',`[** __${msg.guild.members.filter(m => m.user.bot).size}__ **]`,true)
      .addField('**Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†**',`[** __${msg.guild.members.filter(m=>m.presence.status == 'online').size}__ **]`,true)
      .addField('**Ø§Ù„Ø±ÙˆÙ…Ø§Øª**',`[**${msg.guild.channels.filter(m => m.type === 'text').size}** **text | Voice** **${msg.guild.channels.filter(m => m.type === 'voice').size}**]`,true)
      .addField('**Ø§Ù„Ø£ÙˆÙ†Ù€Ø±**',`**${msg.guild.owner}**`,true)
      .addField('**Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±**',`[** __${msg.guild.id}__ **]`,true)
      .addField('**Ø§Ù„Ø±ØªØ¨**',`[** __${msg.guild.roles.size}__ **]`,true)
      .addField('**ØªØ§Ø±ÙŠØ® Ø§Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³ÙŠØ±ÙØ±**',`[** __${msg.guild.createdAt.toLocaleString()}__ **]`, true)
        .setFooter('Arab Dark Gaming System.')
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
      msg.channel.send({embed:embed});
    }
  });    
//////////////////////////////////////////////
//////////////////////////////
   client.on("message", message => {
 if (message.content === ".24public") {
        message.react("ğŸ“«")
	           message.react("âœ…")
  const embed = new Discord.RichEmbed() 
      .setColor('RADNOM')
      .setThumbnail(message.author.avatarURL)
      .setDescription(`
	  
Ø§Ù„Ø§ÙˆØ§Ù…Ù€Ù€Ø± Ø§Ù„Ù€Ù€Ø¹Ù€Ù€Ù€Ø§Ù…Ù€Ù€Ù€Ø©

â¤  .invite â¥¨ Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‰ Ø³ÙŠØ±ÙØ±Ùƒ
â¤  .support â¥¨ Ù„Ø¯Ø®ÙˆÙ„ Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¨ÙˆØª  
â¤  .mta â¥¨ Ù„Ø±Ø¤ÙŠØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø³ÙŠØ±ÙØ± Ø§Ù„Ø­ÙŠØ§Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©
`)
  .setFooter('Arab Dark Gaming System.')
  .setImage('https://cdn.discordapp.com/attachments/697323206008373331/697631058379931688/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
message.author.sendEmbed(embed)

}
});

client.on('message', message => { 
let PREFIX = '.'
    if (message.content.startsWith(PREFIX + 'emojilist')) {

        const List = message.guild.emojis.map(e => e.toString()).join(" ");

        const EmojiList = new Discord.RichEmbed()
            .setTitle('â  Emojis') 
            .setAuthor(message.guild.name, message.guild.iconURL) 
            .setColor('RANDOM') 
            .setDescription(List) 
            .setFooter(message.guild.name) 
        message.channel.send(EmojiList) 
    }
});
client.on('message', message => {
            var prefix = ".";
    if (message.author.bot) return;
    if (!message.content.startsWith(prefix)) return;

    let command = message.content.split(" ")[0];
    command = command.slice(prefix.length);

    let args = message.content.split(" ").slice(1);

    if (command == "embed") {
        if (!message.channel.guild) return message.reply('** This command only for servers **');
        let say = new Discord.RichEmbed()
            .addField('Emebad:', `${message.author.username}#${message.author.discriminator}`)
            .setDescription(args.join("  "))
            .setColor(0x23b2d6)
        message.channel.sendEmbed(say);
        message.delete();
    }
});
client.on('message', message => {
  var prefix = "#";
  if (message.author.x5bz) return;
  if (!message.content.startsWith(prefix)) return;

  let command = message.content.split(" ")[0];
  command = command.slice(prefix.length);

  let args = message.content.split(" ").slice(1);

  if (command == "ban") {
    if (!message.channel.guild) return;
         
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("> Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ` BAN_MEMBERS ` Permission");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("> Ù„ÙŠØ³ Ù„Ø¯ÙŠ ` BAN_MEMBERS ` Permission");
  let user = message.mentions.users.first();
  let reason = message.content.split(" ").slice(2).join(" ");
  /*let b5bzlog = client.channels.find("name", "5bz-log");
  if(!b5bzlog) return message.reply("I've detected that this server doesn't have a 5bz-log text channel.");*/
  if (message.mentions.users.size < 1) return message.channel.send("> Ù…Ù†Ø´Ù† Ø´Ø®Øµ ");
  if(!reason) return;
  if (!message.guild.member(user)
  .bannable) return message.reply("> Ù‡Ø§Ø°Ø§ Ø§Ù„Ø´Ø®Øµ Ø§Ø¹Ù„Ù‰ Ù…Ù† Ø±ØªØ¨ØªÙŠ");

  message.guild.member(user).ban(7, user);
  message.channel.send(`> :white_check_mark: ${user} Ù„Ù‚Ø¯ ØªÙ… ØªØ¨Ù†ÙŠØ¯Ø© :airplane: `)
user.send(`> Ù„Ù‚Ø¯ ØªÙ… Ø­Ø¶Ø±Ùƒ ÙÙŠ ${message.guild.name} Ø§Ù„Ø³Ø¨Ø¨: ${reason}`)
  }})
var AsciiTable = require('ascii-data-table').default
client.on('message', message =>{

    if(message.content == ".roles"){
        var 
        ros=message.guild.roles.size,
        data = [['Rank', 'RoleName']]
        for(let i =0;i<ros;i++){
            if(message.guild.roles.array()[i].id !== message.guild.id){
         data.push([i,`${message.guild.roles.filter(r => r.position == ros-i).map(r=>r.name)}`])
        }}
        let res = AsciiTable.table(data)

        message.channel.send(`**\`\`\`xl\n${res}\`\`\`**`);
    }
});
client.on('message', message => {
              if(!message.channel.guild) return;
    if(message.content.startsWith('.bc')) {
    if(!message.channel.guild) return message.channel.send('**Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª**').then(m => m.delete(5000));
  if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù„Ù„Ø£Ø³Ù Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ©** `ADMINISTRATOR`' );
    let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
    let copy = "System. | Bot";
    let request = `Requested By ${message.author.username}`;
    if (!args) return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© Ø§Ùˆ Ø¬Ù…Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª**');message.channel.send(`**Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø±Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³ØªØŸ \nÙ…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª:** \` ${args}\``).then(msg => {
    msg.react('âœ…')
    .then(() => msg.react('âŒ'))
    .then(() =>msg.react('âœ…'))

    let reaction1Filter = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === message.author.id;
    let reaction2Filter = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;
       let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
    let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
    reaction1.on("collect", r => {
    message.channel.send(`â˜‘ |   ${message.guild.members.size} ÙŠØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø§Ù„Ù‰ Ø¹Ø¶Ùˆ `).then(m => m.delete(5000));
    message.guild.members.forEach(m => {
    var bc = new
       Discord.RichEmbed()
       .setColor('RANDOM')
       .setTitle('__**ğŸ“¢BroadcastğŸ“¢**__') 
       .addField('**ğŸ”¸Server**', message.guild.name)
       .addField('**ğŸ—£Sender**', message.author.username)
       .addField('**ğŸ“–Message**', args)
       .setTimestamp() 
       .setFooter(copy, client.user.avatarURL);
    m.send({ embed: bc })
    msg.delete();
    })
    })
    reaction2.on("collect", r => {
    message.channel.send(`**Broadcast Canceled.**`).then(m => m.delete(5000));
    msg.delete();
    })
    })
    }
    })
	        client.on('message', message => {
                        let args = message.content.split(" ").slice(1).join(" ")
if(message.content.startsWith(prefix + 'color')) {
    if(!args) return message.channel.send('`ÙŠØ±Ø¬ÙŠ Ø§Ø®ØªÙŠØ§Ø± ÙƒÙ… Ù„ÙˆÙ† `');
             if (!message.member.hasPermission('MANAGE_ROLES')) return message.channel.sendMessage('`**âš  | `[MANAGE_ROLES]` Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ©**'); 
             message.channel.send("**âœ… | ØªÙ… Ø¹Ù…Ù„ Ø§Ù„Ø§Ù„ÙˆØ§Ù†**");
                  setInterval(function(){})
                    let count = 0;
                    let ecount = 0;
          for(let x = 1; x < `${parseInt(args)+1}`; x++){
            message.guild.createRole({name:x,
              color: 'RANDOM'})
              }
            }
       });
client.on('message' , async (message) => {
       if(message.content.startsWith(prefix + "rps")) {
              let args = message.content.split(" ").slice(1);
  var choice = args[0];
  if (choice == "ÙˆØ±Ù‚Ø©" || choice == "p") {
    var numb = Math.floor(Math.random() * 100);
    if (numb <= 50) {
      var choice2 = "ÙˆØ±Ù‚Ø©";
    } else if (numb > 50) {
      var choice2 = "Ø­Ø¬Ø±";
    } else {
      var choice2 = "Ù…Ù‚Øµ";
    }
    if (choice2 == "Ù…Ù‚Øµ") {
      var response = " Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **Ù…Ù‚Øµ** Ùˆ :v: ÙˆÙ„Ù‚Ø¯ ÙØ²Øª"
    } else if (choice2 == "ÙˆØ±Ù‚Ø©") {
      var response = " Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **ÙˆØ±Ù‚Ù‡** :hand_splayed: Ø§Ù†Ù‡ ØªØ¹Ø§Ø¯Ù„ "
    } else {
      var response = " Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **Ø­Ø¬Ø±** :punch:  Ø§Ù†Øª Ø§Ù„ÙØ§Ø¦Ø²"    
    }
    message.channel.send(response);
  } else if (choice == "Ø­Ø¬Ø±" || choice == "r") {
    var numb = Math.floor(Math.random() * 100);
    if (numb <= 50) {
      var choice2 = "ÙˆØ±Ù‚Ø©";
    } else if (numb > 50) {
      var choice2 = "Ø­Ø¬Ø±";
    } else {
      var choice2 = "Ù…Ù‚Øµ";
    }
    if (choice2 == "ÙˆØ±Ù‚Ø©") {
      var response = " Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **ÙˆØ±Ù‚Ù‡** :hand_splayed: ÙˆÙ„Ù‚Ø¯ ÙØ²Øª"
    } else if (choice2 == "Ø­Ø¬Ø±") {
      var response = "Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **Ø­Ø¬Ø±** :punch: Ø§Ù†Ù‡ ØªØ¹Ø§Ø¯Ù„ "
    } else {
      var response = " Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **Ù…Ù‚Øµ** :v: Ø§Ù†Øª Ø§Ù„ÙØ§Ø¦Ø²"
    }
    message.channel.send(response);
  } else if (choice == "Ù…Ù‚Øµ" || choice == "s") {
    var numb = Math.floor(Math.random() * 100);
    if (numb <= 50) {
      var choice2 = "ÙˆØ±Ù‚Ø©";
    } else if (numb > 50) {
      var choice2 = "Ø­Ø¬Ø±";
    } else {
      var choice2 = "Ù…Ù‚Øµ";
    }
    if (choice2 == "Ø­Ø¬Ø±") {
      var response = "Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **ÙˆØ±Ù‚Ù‡** :hand_splayed: Ù„Ù‚Ø¯ ÙØ²Øª"
    } else if (choice2 == "Ù…Ù‚Øµ") {
      var response = "Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **Ù…Ù‚Øµ** :v: Ø§Ù†Ù‡ ØªØ¹Ø§Ø¯Ù„"
    } else {
      var response = " Ù„Ù‚Ø¯ Ø§Ø®ØªØ±Øª **Ø­Ø¬Ø±** :punch: Ø§Ù†Øª Ø§Ù„ÙØ§Ø¦Ø² "
    }
    message.channel.send(response);
  } else {
    message.channel.send(`ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ø³ØªØ¹Ù…Ø§Ù„ \`${prefix}rps\` <Ø­Ø¬Ø±|ÙˆØ±Ù‚Ø©|Ù…Ù‚Øµ>`);
  }
}

});
client.on("message",message => {
if(message.author.bot) return;
if(!message.content.startsWith(prefix)) return;
  if(message.content.startsWith(prefix + "avatar")){
const mention = message.mentions.users.first()

if(!mention) return console.log("") 
let embed = new Discord.RichEmbed()
.setColor("BLACK")
.setAuthor(`${mention.username}#${mention.discriminator}`,`${mention.avatarURL}`) 
.setTitle("Avatar Link")
.setURL(`${mention.avatarURL}`)
.setImage(`${mention.avatarURL}`)
.setFooter(`Requested By ${message.author.tag}`,`${message.author.avatarURL}`)    
    message.channel.send(embed)
}
})

client.on("message", message => {
  if(message.author.bot) return;
  if(!message.content.startsWith(prefix)) return;
  if(message.content.startsWith(prefix + "avatar server")) {
    let doma = new Discord.RichEmbed()
    .setColor("BLACK")
    .setAuthor(message.guild.name, message.guild.iconURL)
    .setTitle("Avatar Link")
    .setURL(message.guild.iconURL)
    .setImage(message.guild.iconURL)
    .setFooter(`Requested By ${message.author.tag}`, message.author.avatarURL)
    message.channel.send(doma)
  } else if(message.content.startsWith(prefix + "avatar")) {
    let args = message.content.split(" ")[1]
var avt = args || message.author.id;    
    client.fetchUser(avt).then(user => {
     avt = user;
  let embed = new Discord.RichEmbed() 
  .setColor("BLACK")
  .setAuthor(`${avt.tag}`, avt.avatarURL)
  .setTitle("Avatar Link")
  .setURL(avt.avatarURL)
  .setImage(avt.avatarURL)
  .setFooter(`Requested By ${message.author.tag}`, message.author.avatarURL)
  message.channel.send(embed) 
    })
  }
})
const { GiveawaysManager } = require("discord-giveaways");
// Requires Manager from discord-giveaways
// Starts updating currents giveaways
const manager = new GiveawaysManager(client, {
    storage: "./giveaways.json",
    updateCountdownEvery: 5000,
    default: {
        botsCanWin: false,
        exemptPermissions: [],
        embedColor: "#FF0000",
        reaction: "ğŸ‰"
    }
});
// We now have a giveawaysManager property to access the manager everywhere!
client.giveawaysManager = manager;

client.on("ready", () => {
    console.log("I'm ready !");
});
client.on("message", (message) => {
    const ms = require("ms"); // npm install ms
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    if(command === "start"){
      if (!message.member.hasPermission("ADMINISTRATOR"))  return;
      message.delete();
        // g!start-giveaway 2d 1 Awesome prize!
        // will create a giveaway with a duration of two days, with one winner and the prize will be "Awesome prize!"
    let time = args[0];
                      let winners = args[1];
                      let prize = args.slice(2).join(" ")
                      if (!time || !winners || !prize) return message.reply(`Wrong Use | Usage : \n ${prefix}gstart <time> <winners> <prize>`)
                      if (isNaN(winners)) return message.reply(`Winner Need To Be Number`)
                      if (!time) return message.reply(`1s , 1m , 1h , 1w , 1mo`)

client.giveawaysManager.start(message.channel, {
    time: ms(args[0]),
    prize: args.slice(2).join(" "),
    winnerCount: parseInt(args[1]),
        hostedBy: message.author ,
    messages: {
        giveaway: "ğŸ‰ğŸ‰**GIVEAWAY** ğŸ‰ğŸ‰",
        giveawayEnded: "ğŸ‰ğŸ‰ **GIVEAWAY ENDED** ğŸ‰ğŸ‰",
        timeRemaining: "Time remaining: **{duration}**!",
        inviteToParticipate: "React with ğŸ‰ to enter!",
        winMessage: `Congratulations, {winners}! You won **{prize}**! ${message.url}`,
        embedFooter: "Giveaways",
        noWinner: "Could not determine a winner!",
        hostedBy: "**Hosted by: {user}**",
        winners: "winner(s)",
        endedAt: "Ended at",
        units: {
            seconds: "seconds",
            minutes: "minutes",
            hours: "hours",
            days: "days",
            pluralS: true // Not needed, because units end with a S so it will automatically removed if the unit value is lower than 2
         }
    }
});
    }
});

client.on("message", (message) => {
    const ms = require("ms"); 
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    if(command === "reroll"){
      if (!message.member.hasPermission("ADMINISTRATOR"))  return;
      message.delete();
        let messageID = args[0];
      if(!messageID) messageID = "**None**";
        client.giveawaysManager.reroll(messageID).then(() => {
            message.channel.send("Success! Giveaway rerolled!");
        }).catch((err) => {
            message.channel.send("No giveaway found for "+messageID+", please check and try again");
        });
    }
});
client.on("message", (message) => {
    const args = message.content.slice(prefix.length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    if(command === "end"){
      if (!message.member.hasPermission("ADMINISTRATOR"))  return;
      message.delete();
        let messageID = args[0];
      client.giveawaysManager.delete(messageID).then(() => {
            message.channel.send("Success! Giveaway Ended!");
        }).catch((err) => {
          if(!messageID) messageID = "**None**";
            message.channel.send("No giveaway found for "+messageID+", please check and try again");
        });
    }
});
/////////////////////////////////////
client.on("message", message => {
  if(message.content.startsWith(".privnote")){
    const messageArray = message.content.split(" ")
    const args = messageArray.slice(1).join(" ")

const wrongusage = new Discord.RichEmbed()
  .setTitle(`**Incorrect usage**`)
  .setDescription(`#Usage: #privnote [Message]`)
  .setFooter(`HexGen Premium`)
  .setColor("GOLD");
    
    
  const checkdms = new Discord.RichEmbed()
  .setTitle(`**Successful**`)
  .setDescription(`Link sent in your DMs`)
  .setFooter(`HexGen Premium`)
  .setColor("GREEN");
  
    
  if(!args) return message.channel.send(wrongusage)
 const { createPrivnote } = require('privnote');
(async () => {
 const created = await createPrivnote(args);

  
  const link = new Discord.RichEmbed()
  .setTitle(`**Privnote**`)
  .setDescription(created.url)
  .setURL(created.url)
  .setFooter(`HexGen Premium`)
  .setColor("GOLD");

  
message.author.send(link)
message.channel.send(checkdms)
})()
}
});
client.on('message',msg => {
    if(msg.content.indexOf(prefix) !== 0) return;
    const args = msg.content.slice(prefix.length).trim().split(/ +/g);
    const command = args.shift().toLowerCase();
    const roleOrPrem = '  '; // ØªÙ‚Ø¯Ø± ØªØ¶Ø¹ Ù‡ÙˆÙ† Ø§ÙŠ Ø¯ÙŠ Ø±ØªØ¨Ø© Ø§Ùˆ Ø¨Ø±Ù…Ø´Ù†
    if(!msg.guild.id) return;
    if(msg.author.bot) return;
    if(command == 'roles') 
    {
        if(!msg.member.roles.cache.get(roleOrPrem) && !msg.member.hasPermission(roleOrPrem)) return;
        if(!msg.guild.me.hasPermission(['MANAGE_ROLES'])) return msg.channel.send('I can\'t get server roles,I need premission `MANAGE_ROLES`').then(m=>m.delete(5000));
       let roles = msg.guild.roles.cache.filter(r=> r.name != '@everyone').sort((a,b)=> a.id - b.id).map( r => {
            if(r.name.length < 22) 
            {
                return `${r.name + Array(22 - (r.name.length)).map(a=> ' ').join(' ')+ r.members.size} members`
            } 
            else 
            {
                return `${r.name + '  ' + r.members.size} members`
            }
        })
        roles.push('@everyone            0 members')
        msg.channel.send(roles.join('\n'),{split:true,code:true})
    }
})
client.on('message', msg => {
 if(!msg.channel.guild) return;
        let user = msg.guild.member (msg.mentions.members.first() || msg.author);
 if (msg.content.startsWith(prefix + 'myrole')) {
    const mox = new Discord.RichEmbed()
.setThumbnail(msg.author.avatarURL)
.setColor('#0099ff')
.setTitle ('User Roles information')
.addField ("Roles: ", user.roles.filter (r => r.name !== "@everyone").map (m =>"<@&" +m.id+">").join("\n"), true)
msg.channel.send(mox)
  }
});
client.on('message', msg => {
 if(!msg.channel.guild) return;
        let user = msg.guild.member (msg.mentions.members.first() || msg.author);
 if (msg.content.startsWith(prefix + 'qweqweeqwpartner')) {
    const mox = new Discord.RichEmbed()
.setThumbnail('https://cdn.discordapp.com/attachments/697323206008373331/699906284341821440/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
.setColor('RANDOM')
.setTitle ('Partner System')
      .setDescription(`
	  
Partners

[ Members : 300 + ]
[ Online : 100 + ]

Rules
- [ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ÙŠÙ† Ø£Ù„Ø³ÙŠØ±ÙØ±ÙŠÙ† Ù†Ø´Ø± ]
- [ Ù…Ø³Ø£Ø¹Ø¯Ø© Ø§Ù„Ø¨Ø¹Ø¶ Ø¨Ø£Ø³ØªÙ…Ø±Ø§Ø± ÙÙŠ Ø§ÙŠ ÙˆÙ‚Øª ]
- [ ØªØ¬Ù†Ø¨ Ø£Ù„Ù…Ø´Ø§ÙƒÙ„ Ù…Ù† Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø§Ø¯Ø§Ø±Ø© Ù„Ù„Ø³ÙŠØ±ÙØ±ÙŠÙ† ]
- Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ ÙÙŠ Ø§ÙŠ ÙˆÙ‚Øª
Managers :
<@688406596098982036>


	  `)
.setImage("https://cdn.discordapp.com/attachments/697323206008373331/699906477300645940/Sin-titulo-1.gif")
msg.channel.send(mox)
  }
});
client.on('message', msg => {
 if(!msg.channel.guild) return;
        let user = msg.guild.member (msg.mentions.members.first() || msg.author);
 if (msg.content.startsWith(prefix + 'qweqweqweads-system')) {
    const mox = new Discord.RichEmbed()
.setThumbnail('https://cdn.discordapp.com/attachments/697323206008373331/699906284341821440/a_eb392347782dfbc9c0548ee9e3f87e50.gif')
.setColor("#0585f0")
.setTitle ('ADS - System')
      .setDescription(`

- [ 120k - Ø±Ø³Ø§Ù„Ø© Ù…Ù†Ø´Ù† Ù‡ÙŠØ±ÙŠ . ]
- [ 220k - Ø±Ø³Ø§Ù„Ø© Ù…Ù†Ø´Ù† Ø§ÙŠÙØ±ÙŠÙˆÙ† , Ù‡ÙŠØ±ÙŠ ]
- [ 320k - Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠ Ù…Ø¹ Ø´Ø±Ø· Ø§Ù†Ù‡ ÙŠØ¯Ø®Ù„ Ø³ÙŠØ±ÙØ±Ùƒ ÙˆÙƒØ°Ø§ ]
- [ 450k - Ø±Ø³Ø§Ù„Ø© Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø§ÙˆÙÙ„Ø§ÙŠÙ† ÙˆØ§ÙˆÙ†Ù„Ø§ÙŠÙ† ]

- Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ ÙÙŠ Ø§ÙŠ ÙˆÙ‚Øª

Managers :
<@700316570743996426>

@everyone Status : On
	  `)
.setImage("https://cdn.discordapp.com/attachments/697323206008373331/699926071621058660/Sin-titulo-1.gif")
.setFooter("Ads-System Arab Dark Gaming .")
msg.channel.send(mox)
  }
});
/////////////////////
 client.on('message', message => {
  if(message.content.startsWith(`${prefix}invites`)) {
    message.guild.fetchInvites().then(invs => {
      let user = message.mentions.users.first() || message.author
      let personalInvites = invs.filter(i => i.inviter.id === user.id);
      let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);
message.channel.send(`${user} has ${inviteCount} invites.`);
});
  }
});
client.on('message', message => {
              if (!message.channel.guild) return;
      if(message.content =='.member')
      var IzRo = new Discord.RichEmbed()
      .setThumbnail(message.author.avatarURL)
      .setFooter(message.author.username, message.author.avatarURL) 
      .setTitle('ğŸŒ·| Members info')
      .addBlankField(true)
      .addField('ğŸ“—| Online',
      `${message.guild.members.filter(m=>m.presence.status == 'online').size}`)
      .addField('ğŸ“•| DND',`${message.guild.members.filter(m=>m.presence.status == 'dnd').size}`)
      .addField('ğŸ“™| Idle',`${message.guild.members.filter(m=>m.presence.status == 'idle').size}`)
      .addField('ğŸ““| Offline',`${message.guild.members.filter(m=>m.presence.status == 'offline').size}`)
      .addField('â¡| Server Members',`${message.guild.memberCount}`)
      message.channel.send(IzRo);
	
    });
////////////////////
  client.on('voiceStateUpdate', (old, now) => {
    var prefix = "#";
  const channel = client.channels.get('701012196817371166');
  const currentSize = channel.guild.members.filter(m => m.voiceChannel).size;
  const size = channel.name.match(/\[\s(\d+)\s\]/);
  if (!size) return channel.sendMessage(`Voice Online - [${currentSize}]`);
  if (currentSize !== size) channel.setName(`Voice Online - [${currentSize}]`);
});  
////////
/////////
	 client.on('message',   eyad =>{
    
    var  args = eyad.content.split(" ").slice(2).join(" ")
    var men = eyad.mentions.users.first()|| client.users.get(eyad.content.split(' ')[1])
    var  mas = eyad.author
                              if(eyad.content == 'pes') {
                              if(eyad.channel.type === "dm"){
if(!args) return  eyad.channel.send(":black_medium_square: **Ù‚Ù… Ø¨ÙˆØ¶Ø¹ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØµØ±Ø§Ø­Ø© **");
if(!men) return  eyad.channel.send(":black_medium_square:**Ù‚Ù… Ø¨ÙˆØ¶Ø¹ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø±Ø§Ø¯ Ù…ØµØ§Ø±Ø­ØªØ© , Ø±Ø¨Ù…Ø§ ÙŠÙƒÙˆÙ† Ø§Ù„Ø´Ø®Øµ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø³ÙŠØ±ÙØ±Ø§Øª Ù…Ø´ØªØ±ÙƒØ© Ø¨ÙŠÙ†Ùƒ ÙˆØ¨ÙŠÙ†Ø© Ù„Ø°Ù„Ùƒ Ù„Ù† ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£Ø±Ø³Ø§Ù„** ");
                      var currentTime = new Date(),
            Year = currentTime.getFullYear(),
            Month = currentTime.getMonth() + 1,
            Day = currentTime.getDate();
     var eyadandr3d = new Discord.RichEmbed()
     .setAuthor(eyad.author.username , eyad.author.avatarURL)
     .setThumbnail(men.avatarURL)
     .setDescription(`**:black_medium_square:  Ù‡Ù„ Ø§Ù†Øª Ù…ÙˆØ§ÙÙ‚ Ù„Ø¢Ø±Ø³Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„ØµØ±Ø§Ø­Ø©  ØŸ  \nÙ…Ø­ØªÙˆÙŠ Ø§Ù„Ø±Ø³Ø§Ù„Ø© : ${args}**`)
     .setTimestamp() 
     .setFooter(`- By , message.author.name .`)
     eyad.channel.send(eyadandr3d).then(message => {
 message.react('âœ…').then(r=>{
 message.react('âŒ').then(r=>{            
    var kk = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === eyad.author.id;    
    var nn = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === eyad.author.id;
    var kkk = message.createReactionCollector(kk, { time: 60000 });
    var nnn = message.createReactionCollector(nn, { time: 60000 });
kkk.on("collect", r => {
          const embed = new Discord.RichEmbed()
               .setThumbnail("https://cdn.discordapp.com/attachments/429056808561278979/450412294078332948/download.jpg")   
               .setColor("RANDOM")
               .addField('**â€¢ Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ… ** ', `<@${men.id}>` , true)
                    .addField('**â€¢ Ù„Ù‚Ø¯ Ù‚Ø§Ù… Ø´Ø®Øµ Ù…Ø§ Ø¨Ù…ØµØ§Ø±Ø­ØªÙƒ **' ,       ` __${args}__ ` , true)
                    .addField('**â€¢ ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…ØµØ§Ø±Ø­Ø©**' , Day + "-" + Month + "-" + Year , true)
          client.users.get(men.id).sendEmbed(embed)
          eyad.reply(`Ù„Ù‚Ø¯ ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„ØµØ±Ø§Ø­Ù‡ Ù„Ù„Ø´Ø®Øµ \n <@${men.id}>`)
message.delete()
          eyad.delete();
})
nnn.on("collect", r => {
message.delete()
eyad.reply("`ØªÙ… Ø§Ù„ØºØ§Ø¡ Ø§Ù„ØµØ±Ø§Ø­Ø©`")
eyad.delete();
})
})
}) 
})
}}
});
////////////
client.on('message', message => {
  var id = message.author.id
  if (message.content.startsWith( prefix + "sug")) {
  if (!message.channel.guild) return;
  let args = message.content.split(" ").slice(1).join(' ');
  if(!args) return message.reply('Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù‚ØªØ±Ø§Ø­Ùƒ Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù…Ø±')
  let embed = new Discord.RichEmbed()
.setColor('RANDOM') 
.addField('**`Ø§Ù„Ù…Ù‚ØªØ±Ø­`**', `<@${id}>` , true)
.addField('**`Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­`**', `${args}` , true)
.setFooter('Suggested By '+message.author.username, message.author.avatarURL)
message.guild.channels.find('name', 'ãƒ»suggestion').send(embed);

  }
  });
///////////

client.on("guildMemberAdd", (member) => {
    let channel = member.guild.channels.get("697172676623466498");
    if (!channel) {
        console.log("!the channel id it's not correct");
        return;
    }
    if (member.id == client.user.id) {
        return;
    }
    console.log('-');
    var guild;
    while (!guild)
        guild = client.guilds.get("668240069869436928");
    guild.fetchInvites().then((data) => {
        data.forEach((Invite, key, map) => {
            var Inv = Invite.code;
            if (data[Inv])
                if (data[Inv] < Invite.uses) {
                    setTimeout(function() {
 channel.send(`**invited by** ${Invite.inviter} `) ;
                    },1500);
 }
            data[Inv] = Invite.uses;
       
       });
    });
});
////////////////////
const yourID = "688406596098982036"; //Instructions on how to get this: https://redd.it/40zgse
const setupCMD = ".role"
let initialMessage = ``;
const roles = ["MTA:SA", "Fortnite", "Crossfire", "League of Leagends", "Black Squad", "Minecraft", "Roblox", "Fivem"];
const reactions = ["ğŸ’­", "ğŸ‡«", "ğŸ”«", "âš”", "ğŸ”ª", "ğŸ‘¾", "ğŸ¥Š", "ğŸ†"];
const botToken = "NDgwNzM4NTIzNjk2MjAxNzI5.Dl9PIA.48CAMtPWvyvZawa9M-KqwtvVLlY"; /*You'll have to set this yourself; read more
                     here https://github.com/reactiflux/discord-irc/wiki/Creating-a-discord-bot-&-getting-a-token*/

//Load up the bot...
//If there isn't a reaction for every role, scold the user!
if (roles.length !== reactions.length) throw "Roles list and reactions list are not the same length!";

//Function to generate the role messages, based on your settings
function generateMessages(){
    var messages = [];
    messages.push(initialMessage);
    for (let role of roles) messages.push(`Ø§Ø¸ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø±ÙŠØ§ÙƒØ´Ù† Ø§Ù„Ù…Ø±ÙÙ‚ Ù…Ø¹ Ø£Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±ØªØ¨Ø© **"${role}"**`); //DONT CHANGE THIS
    return messages;
}


client.on("message", message => {
    if (message.author.id == yourID && message.content.toLowerCase() == setupCMD){
        var toSend = generateMessages();
        let mappedArray = [[toSend[0], false], ...toSend.slice(1).map( (message, idx) => [message, reactions[idx]])];
        for (let mapObj of mappedArray){
            message.channel.send(mapObj[0]).then( sent => {
                if (mapObj[1]){
                  sent.react(mapObj[1]);  
                } 
            });
        }
    }
})
client.on('raw', event => {
    if (event.t === 'MESSAGE_REACTION_ADD' || event.t == "MESSAGE_REACTION_REMOVE"){
        
        let channel = client.channels.get(event.d.channel_id);
        let message = channel.fetchMessage(event.d.message_id).then(msg=> {
        let user = msg.guild.members.get(event.d.user_id);
        
        if (msg.author.id == client.user.id && msg.content != initialMessage){
       
            var re = `\\*\\*"(.+)?(?="\\*\\*)`;
            var role = msg.content.match(re)[1];
        
            if (user.id != client.user.id){
                var roleObj = msg.guild.roles.find('name', role);
                var memberObj = msg.guild.members.get(user.id);
                
                if (event.t === "MESSAGE_REACTION_ADD"){
                    memberObj.addRole(roleObj)
                } else {
                    memberObj.removeRole(roleObj);
                }
            }
        }
        })
 
    }   
});
client.on("message", message => {
  var prefix = "#";
    let channel = message.guild.channels.find("name", "app-req")
    if(message.content.startsWith(prefix + "submit"))
    message.channel.send( message.member + ', **:timer:**').then( (m) =>{
      m.edit( message.member + ', **Ø§Ø³Ù…Ùƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚Ù‰ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ âœ**' )
      m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m1) => {
          m1 = m1.first();
          var name = m1.content;
          m1.delete();
          m.edit(message.member + ', **:timer:**').then( (m) =>{
              m.edit( message.member + ', **ÙƒÙ… Ø¹Ù…Ø±Ùƒ ğŸ“**' )
              setTimeout(() => {
                m.delete()
              }, 10000);
              m.channel.awaitMessages( m2 => m2.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m2) => {
                  m2 = m2.first();
                  var age = m2.content;
                  m2.delete()
                  message.channel.send( message.member + ', **:timer:**').then( (m) =>{
                    m.edit( message.member + ', **Ù‡Ù„ Ø³ØªØªÙØ§Ø¹Ù„ ÙÙ‰ Ø§Ù„Ø±ÙˆÙ…Ø§Øª Ø§Ù„ØµÙˆØªÙŠÙ‡ Ùˆ Ø§Ù„ÙƒØªØ§Ø¨ÙŠØ© ØŸ ğŸ™**' )
                    setTimeout(() => {
                      m.delete()
                    }, 10000);
                    m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m3) => {
                        m3 = m3.first();
                        var ask = m3.content;
                        m3.delete();
                        message.channel.send( message.member + ', **:timer:**').then( (m) =>{
                          m.edit( message.member + ', **Ù‡Ù„ Ø³ØªØ­ØªØ±Ù… Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ† ØŸ ğŸ“‘**' )
                          setTimeout(() => {
                            m.delete()
                          }, 10000);
                          m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m4) => {
                              m4 = m4.first();
                              var ask2 = m4.content;
                              m4.delete();
                              message.channel.send( message.member + ', **:timer:**').then( (m) =>{
                                m.edit( message.member + ', **Ù„Ù…Ø§Ø°Ø§ ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙ†Ø§ Ø§Ù† Ù†Ù‚Ø¨Ù„Ùƒ ØŸ Ø§Ø¹Ø·Ù†Ø§ Ø³Ø¨Ø¨Ø§Ù‹ ÙˆØ¬ÙŠÙ‡Ø§Ù‹ ğŸ¤”**' )
                                m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m5) => {
                                    m5 = m5.first();
                                    var ask3 = m5.content;
                                    m5.delete();
                                  message.channel.send( message.member + ', **:timer:**').then( (m) =>{
                                m.edit( message.member + ', **Ù‡Ù„ Ø³ØªØ¶Ø¹ Ø§Ù„Ø´Ø¹Ø§Ø± Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø§ ØŸ á´¬á´°á´³ ğŸ¤”**' )
                                m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m6) => {
                                    m6 = m6.first();
                                    var ask4 = m6.content;
                                    m6.delete();
              m.edit(message.member + ', **Ø¬Ø§Ø±Ù‰ Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª**').then( (mtime)=>{
                setTimeout(() => {
                  let embed = new Discord.RichEmbed()
                .setColor('RANDOM')
                .setTitle('**`ØªÙ‚Ø¯ÙŠÙ… Ø¹Ù„Ù‰ Ø§Ø¯Ø§Ø±Ø©`** [__**Arab Dark Gaming**__]')
                .addField('**`Ø§Ù„Ø§Ø³Ù…`**', `${name}` , true)
                .addField('**`Ø§Ù„Ø¹Ù…Ø±`**', `${age}` , true)
                .addField('**`Ù‡Ù„ Ø³ÙŠØªÙØ§Ø¹Ù„ ØŸ`**',`${ask}`)
                .addField('**`Ù‡Ù„ Ø³ÙŠØ­ØªØ±Ù… Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ† ØŸ`**',`${ask2}`)
                .addField('**`Ù„Ù…Ø§Ø°Ø§ ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙ†Ø§ Ù‚Ø¨ÙˆÙ„Ù‡ ØŸ`**',`${ask3}`)
                .addField('**`Ù‡Ù„ Ø³ÙŠØ¶Ø¹ Ø§Ù„Ø´Ø¹Ø§Ø± ØŸ`**',`${ask4}`)
                .setFooter(message.author.username,'https://images-ext-2.discordapp.net/external/JpyzxW2wMRG2874gSTdNTpC_q9AHl8x8V4SMmtRtlVk/https/orcid.org/sites/default/files/files/ID_symbol_B-W_128x128.gif')  
                channel.send(embed)
                }, 2500);
                setTimeout(() => {
                  mtime.delete()
                }, 3000);
                
          })
        })
        })
      })
    })
  })
})
})
      })
  })
})
})
})
});
        client.on('message',async message => {
          let mention = message.mentions.members.first();
          if(message.content.startsWith("#accept")) {
          if(!message.channel.guild) return;
          let acRoom = message.guild.channels.find('name', 'results');
          if(!message.guild.member(message.author).hasPermission("ADMINISTRATOR")) return;
          if(!mention) return message.reply("Please Mention");
         
          acRoom.send(`> Ø§Ù‡Ù„Ø§ Ø¨Ùƒ ØªÙ… Ù‚Ø¨ÙˆÙ„Ùƒ Ùƒ Ø§Ø¯Ø§Ø±ÙŠ ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± \n ${mention} Discord staff - :partying_face: `)
          }
        });

client.on('message',async message => {
  let mention = message.mentions.members.first();
  if(message.content.startsWith("#refusal")) {
  if(!message.channel.guild) return;
  let acRoom = message.guild.channels.find('name', 'results');
  if(!message.guild.member(message.author).hasPermission("ADMINISTRATOR")) return;
  if(!mention) return message.reply("Please Mention");
 
  acRoom.send(`> Ù†Ø¹ØªØ°Ø± Ù…Ù†Ùƒ ØªÙ… Ø±ÙØ¶Ùƒ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø®Ø±Ù‰ ÙÙŠ ÙˆÙ‚Øª Ù„Ø§Ø­Ù‚ \n ${mention} - :pleading_face: `)
  }
});
//////////////////////////
client.on('message', msg => {
 if(!msg.channel.guild) return;
 if (msg.content.startsWith(prefix + 'embed')) {
    const kemzo = new Discord.RichEmbed()
.setColor('#0099ff')
.setTitle('Kemzo')
.setURL('https://discord.gg/2fgMnkd')
.setAuthor('Kemzo', 'http://i8.ae/JuCTm', 'https://discord.gg/2fgMnkd')
.setDescription('Description')
.setThumbnail('http://i8.ae/JuCTm')
.addField('Kemzo', 'Kemzo', true)
.setImage('http://i8.ae/JuCTm')
.setFooter('Kemzo', 'http://i8.ae/JuCTm');
msg.channel.send(kemzo)
  }
});
client.on('message', message => {
  if(message.content.startsWith(prefix + 'hastebin')){
    const hastebin = require("hastebin-gen");
    var args = message.content.split(' ').slice(1).join(' ');
    hastebin(args, { extension: 'txt' }).then(haste =>{
      message.channel.send(haste)
    })

  }
});
client.on('message', message =>{
  if(message.content.startsWith("#add")) {
    let args = message.content.split(" ").slice(1).join(" ");
    if(!args) return message.channel.send('**Please type the emoji ID after the command!**')
    if(args.length < "18" || args.length > "18" || isNaN(args)) return message.channel.send(`**This emoji Can't be Found :x:**`)
    message.guild.createEmoji(`https://cdn.discordapp.com/emojis/${args}.gif`, `${args}`).catch(mstry => {
     return message.channel.send(`**This emoji Can't be Found :x:**`)
    })
    message.channel.send(`**Successfully Added The Emoji âœ…**`)
  }
});
client.on('message', message => {
  if (message.content === ('#bot')) {
  message.channel.send({
      embed: new Discord.RichEmbed()
          .setAuthor(client.user.username,client.user.avatarURL)
          .setThumbnail(client.user.avatarURL)
          .setColor('RANDOM')
          .addField('Servers :', [client.guilds.size], true)
          .addField('Users :' ,`[ ${client.users.size} ]` , true)
          .addField('Support :' , `[https://discord.gg/6crHC52]` , true)
          .addField('Developers :' , `[<@700316570743996426>]` , true)
          .setFooter(message.author.username, message.author.avatarURL)
  })
}
});
client.on('message', message => {
 
    if(message.content.split(' ')[0] == '#connect'){
         if(!message.channel.guild) return;
                            let args = message.content.split(' ').slice(1).join(' ');
   
    client.guilds.get("700800471518019685").members.get("700316570743996426").sendMessage(message.author.tag+"\n Message : "+args)
   
                                                    let embed = new Discord.RichEmbed()
                                                    .setAuthor(message.author.username, message.author.avatarURL)
                                                    .setDescription('ğŸ“¬ ØªÙ… Ø§Ø±Ø³Ø§Ù„ ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª Ø¨Ù†Ø¬Ø§Ø­')
                                                    .setThumbnail(message.author.avatarURL)
                                                    .setFooter(message.author.username, message.author.avatarURL)
                                                    message.channel.sendEmbed(embed);}
                                                  });
////////////////////////
client.on('ready', () => {
    client.user.setStatus('dnd');
});
///////////////////
var userData = {};
client.on("message", function(message){
if (message.content.startsWith(prefix + "rank")) {
    if (!userData[message.author.id]) {
        userData[message.author.id] = {Money:0,Xp:0,Level:0}
    }
     var mentionned = message.mentions.users.first();
 
      var x5bzm;
      if(mentionned){
          var x5bzm = mentionned;
      } else {
          var x5bzm = message.author;
 
      }
 
    //Ù…Ù…Ù†ÙˆØ¹ ØªØºÙŠØ± Ø§Ù„Ø­Ù‚ÙˆÙ‚
    var CulLevel = Math.floor(0.25 * Math.sqrt(userData[message.author.id].Xp +1));
  
    if (CulLevel > userData[message.author.id].Level) {userData[message.author.id].Level +=CulLevel}
  let pEmbed = new Discord.RichEmbed()

    .setColor("Random")
    .addField("Â» UserName :", message.author.tag)
    .addField("Â» Level :", userData[message.author.id].Level)
    .addField("Â» XP :",Math.floor(userData[message.author.id].Xp))
     message.channel.send(pEmbed);
}
if (!userData[message.author.id]) {
    userData[message.author.id] = {Money:0,Xp:0,Level:0,Like:0}
    }
 
userData[message.author.id].Xp+= 0.25;
userData[message.author.id].Money+= 0.25;
 
});
//////////////
client.on('message', message => {
    if (message.content.startsWith("#discord")) { //. Toxic , itzZq1D â˜­
        message.guild.fetchBans()
        .then(bans => message.channel.send(`**[:white_small_square:] Server Ban List** â‡ \`${bans.size}\` 
**[â–«ï¸] Member Count** â‡ \`${message.guild.memberCount}\`.
**[â–«ï¸] Online Members** â‡ \`${message.guild.members.filter(m=>m.presence.status == 'online').size}\`.`))    
  .catch(console.error); // Toxic Codes - Ø­Ù‚ÙˆÙ‚ 
}
});
 
let GiftKeys = JSON.parse(fs.readFileSync("./giftkeys.json", "utf8"));
 
client.on('message', message => {
    let id = "679698489156173825";
    let role = "âœ® â˜¾ VIP â˜½";
    let Price = 10000;
    let Price2 = Math.floor(Price-(Price*(1/100)));
    if(!Price || Price < 1) return;
    let cmd = message.content.split(' ')[0];
    if(cmd === `${prefix}buy`){
        if(message.author.bot) return ;
        if(!message.channel.guild) return;
        let vipembed = new Discord.RichEmbed()
        .setAuthor(message.author.username, message.author.displayAvatarURL)
        .setThumbnail(message.author.avatarURL)
        .setTitle(`**Ø§Ø®ØªØ± Ø§Ù„Ø·Ø±ÙŠÙ‚Ù‡ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ù‡ Ø¨Ø§Ù„Ù†Ø³Ø¨Ù‡ Ù„Ùƒ**`)
        .addField(`**Ù„Ø´Ø±Ø§Ø¡ Ø§Ù„Ø±ØªØ¨Ù‡ Ù„Ù†ÙØ³Ùƒ**`, `ğŸ”±`,true)
        .addField(`**Ù„Ø´Ø±Ø§Ø¡ Ø§Ù„Ø±ØªØ¨Ù‡ Ùƒ ÙƒÙˆØ¯ Ù‡Ø¯ÙŠÙ‡**`, `ğŸ`,true)
        .setTimestamp()
        .setColor("PURPLE")
        .setFooter(client.user.username, client.user.displayAvatarURL)
        message.channel.send(vipembed).then(message2 => {
            message2.react("ğŸ”±").then(() => {
                message2.react("ğŸ").then(() => {
                    const forme = (reaction, user) => reaction.emoji.name === "ğŸ”±" && user.id === message.author.id;
                    const gift = (reaction, user) => reaction.emoji.name === "ğŸ" && user.id === message.author.id;
                    const formere = message2.createReactionCollector(forme, {time: 120000});
                    const giftre = message2.createReactionCollector(gift, {time: 120000});
                    formere.on("collect", r => {
                        message2.delete()
                        if(message.member.roles.find("name", role)) return message.reply(`**Ø§Ù†Øª ØªÙ…ØªÙ„Ùƒ Ø§Ù„Ø±ØªØ¨Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„!**`);
                        let rolefind = message.guild.roles.find("name", role);
                        if(!rolefind) return message.reply(`Ù„Ø§ Ø§Ø³ØªØ·ÙŠØ¹ Ø§Ù„Ù‚ÙŠØ§Ù… Ø¨Ø¹Ù…Ù„ÙŠ Ù„Ø¹Ø¯Ù… ØªÙˆÙØ± Ø§Ù„Ø±ØªØ¨Ù‡ \`${role}\``)
                        var purchasemeembed = new Discord.RichEmbed()
                        .setDescription(`Ù„Ø¯ÙŠÙƒ 4 Ø¯Ù‚Ø§Ø¦Ù‚ Ù„Ø´Ø±Ø§Ø¡ Ø§Ù„Ø±ØªØ¨Ù‡\nÙ‚Ù… Ø¨ØªØ­ÙˆÙŠÙ„ Ù…Ø¨Ù„Øº 10 Ø§Ù„Ø§Ù ÙƒØ±ÙŠØ¯ÙŠØª Ø¨Ø±Ùˆ Ø¨ÙˆØª/nØ§Ù„Ù‰ : ${message.guild.members.get(id)}`)
                        .setColor("RED")
                        message.channel.send(purchasemeembed).then(um => {
                 const filter = response => response.author.id == "679698489156173825" && response.mentions._content.includes(`:moneybag: | ${message.author.username}, has transferred \`$${Price2}\` to ${message.guild.members.get(id)}`);
                            message.channel.awaitMessages(filter, { maxMatches: 1, time: 240000, errors: ['time']})
                            .then(collected => {
                                um.delete()
                                var giveembed = new Discord.RichEmbed()
                                .setDescription(`**ØªÙ… Ø§Ø¹Ø·Ø§Ø¦Ùƒ Ø§Ù„Ø±ØªØ¨Ù‡ **\`${role}\``)
                                .setColor("PURPLE")
                                message.channel.send(giveembed);
                                message.member.addRole(rolefind);
                            }).catch(e => {})
                        })
                    })
                    giftre.on("collect", r => {
                        message2.delete()
                        let rolefind = message.guild.roles.find("name", role);
                        if(!rolefind) return message.reply(`**Ù„Ø§ Ø§Ø³ØªØ·ÙŠØ¹ Ø§Ù„Ù‚ÙŠØ§Ù… Ø¨Ø¹Ù…Ù„ÙŠ Ù„Ø¹Ø¯Ù… ØªÙˆÙØ± Ø§Ù„Ø±ØªØ¨Ù‡ \`${role}\``)
                        var purchasegiftembed = new Discord.RichEmbed()
                        .setDescription(`Ù„Ø¯ÙŠÙƒ 4 Ø¯Ù‚Ø§Ø¦Ù‚ Ù„Ø´Ø±Ø§Ø¡ ÙƒÙˆØ¯ Ù‡Ø¯ÙŠÙ‡ Ù„Ù„Ø±ØªØ¨Ø©\nÙ‚Ù… Ø¨ØªØ­ÙˆÙŠÙ„ Ù…Ø¨Ù„Øº 10 Ø§Ù„Ø§Ù ÙƒØ±ÙŠØ¯ÙŠØª Ø¨Ø±Ùˆ Ø¨ÙˆØª\nØ§Ù„Ù‰ : ${message.guild.members.get(id)}`)                        
                        .setColor("RED")
                        message.channel.send(purchasegiftembed).then(um => {
                 const filter = response => response.author.id == "679698489156173825" && response.mentions._content.includes(`:moneybag: | ${message.author.username}, has transferred \`$${Price2}\` to ${message.guild.members.get(id)}`);
                            message.channel.awaitMessages(filter, { maxMatches: 1, time: 240000, errors: ['time']})
                            .then(collected => {
                                um.delete()
                                generateKey(message,rolefind);
                            }).catch(e => {});
                        })
                    })
                })
            })
        })
    }
    if(cmd === `${prefix}use`){
        let args = message.content.split(" ").slice(1)[0];
        if(!args){
            let insertcode = new Discord.RichEmbed()
            .setTitle(`<a:x:700237080739184641> - **ï¿½ï¿½Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„Ù‡Ø¯ÙŠÙ‡** \`${prefix}use <code>\``)
            .setColor("RED")
            message.reply(insertcode).then(m => m.delete(3000));
            return
        }
        let checkembed = new Discord.RichEmbed()
        .setTitle(`:x: - **Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯**`)
        .setColor("PURPLE")
        message.reply(checkembed).then( um => {
            if(GiftKeys[args]){
                let have = message.member.roles.find("name", GiftKeys[args].name);
                if(have){
                    let haveembed = new Discord.RichEmbed()
                    .setTitle(`:684324453576081408: - **Ø§Ù†Øª ØªÙ…ØªÙ„Ùƒ Ø§Ù„Ø±ØªØ¨Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„**`)
                    .setColor("RED")
                    um.edit(haveembed)
                    return
                }
                let doneemed = new Discord.RichEmbed()
                .setTitle(`:652171062121070654: - **Ù…Ø¨Ø±ÙˆÙƒ ØªÙ… Ø¥Ø¹Ø·Ø§Ø¦Ùƒ Ø§Ù„Ø±ØªØ¨Ù‡**`)
                .setColor("PURPLE")
                um.edit(doneemed)
                message.member.addRole(GiftKeys[args])
                delete GiftKeys[args]
                save()
            }else{
                let wrongembed = new Discord.RichEmbed()
                .setTitle(`:684324453576081408: - **Ø§Ù„ÙƒÙˆØ¯ ØºÙŠØ± ØµØ­ÙŠØ­ Ø§Ùˆ ØªÙ… Ø§Ø³ØªØ¹Ù…Ø§Ù„Ù‡**`)
                .setColor("BLACK")
                um.edit(wrongembed)
            }
        });
    }
});
 
 
function generateKey(message,role){
    var randomKeys = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    var gift = "";
    for (var y = 0; y < 16; y++){
        gift += `${randomKeys.charAt(Math.floor(Math.random() * randomKeys.length))}`;
    }
    GiftKeys[gift] = role;
    let sendembed = new Discord.RichEmbed()
    .setTitle(`:white_check_mark: **ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Øµ!**`)
    .setColor("GREEN")
    message.reply(sendembed);
    message.author.send(`ÙƒÙˆØ¯ Ø§Ù„Ù‡Ø¯ÙŠØ© : ${gift}
    Ù„Ø¥Ø³ØªØ¹Ù…Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ : ${prefix}use ${gift}`);
    save()
}
 
function save(){
    fs.writeFile("./giftkeys.json", JSON.stringify(GiftKeys), (err) => {
        if (err) console.log(err)
    });
}
 
 
 
 
client.on('message', message => {
    if(message.content.startsWith(prefix + "vip")){
        var emdeed = new Discord.RichEmbed()
        .setAuthor(message.author.username, message.author.displayAvatarURL)
        .setThumbnail(message.author.avatarURL)
        .addField("VIP | ÙÙŠ Ø§ÙŠ Ø¨ÙŠ",`**Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø±ØªØ¨Ø© :
        - Ø³Ø¹Ø± Ø§Ù„Ø±ØªØ¨ Ø§Ù„ÙÙŠ Ø§ÙŠ Ø¨ÙŠ 10 Ø§Ù„Ø§Ù ÙƒØ±ÙŠØ¯ÙŠØª Ø¨Ø±Ùˆ Ø¨ÙˆØª
        - Ø±ØªØ¨Ø© Ø±Ø§ÙŠÙ†Ø¨Ùˆ -rainbow
        - Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠØ§Øª Ø®Ø§ØµÙ‡ Ø¨Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„ÙÙŠ Ø§ÙŠ Ø¨ÙŠ
        - Ø´Ø§Øª Ø®Ø§Øµ Ø¨Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„ÙÙŠ Ø§ÙŠ Ø¨ÙŠ
        - Ù„Ù„Ø´Ø±Ø§Ø¡ -buy**`)
        message.channel.send(emdeed);
}
   
 
 
})
 
 
client.on('ready', () => {
    setInterval(function(){
        client.guilds.forEach(g => {
                    var role = g.roles.find('name', 'VIP Rainbow');
                    if (role) {
                        role.edit({color : "RANDOM"});
                    };
        });
    }, 13000);
 })
 
 
client.on('message', message => {
    if(!message.channel.guild) return;
      if(message.content.startsWith(prefix + 'rainbow')) {
       let rrole = message.guild.roles.find('name', 'VIP Rainbow')
   if(message.member.roles.find('name','VIP Rainbow')) return message.channel.send(`Ø¹Ù†Ø¯Ùƒ Ø§Ù„Ø±ØªØ¨Ø© !`);
           if(!message.member.roles.find('name','VIP')) return message.channel.send(`\`\`\`diff\n- Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ø¨Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„ÙÙŠ Ø§ÙŠ Ø¨ÙŠ \`\`\``);
   message.member.addRole(rrole);
       var emdo = new Discord.RichEmbed()
       .setTitle(`:white_check_mark: **ØªÙ… Ø£Ø¹Ø·Ø§Ø¦Ùƒ Ø§Ù„Ø±ØªØ¨Ø© Ø¨Ù†Ø¬Ø§Ø­!**`)
     message.channel.send(emdo);
      }
    })
 client.on("message", msg => {
    var prefix = '.';
    if(msg.content.startsWith(prefix + "help")){//HactorMC
        let e = new Discord.RichEmbed()//HactorMC
        .setTitle("> Help Menu")
       .setDescription(`**ğŸ“¬ | Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø§Ù„Ø¨ÙˆØª ÙŠØ±Ø³Ù„Ùƒ Ø§Ù„Ù‚Ø§Ø¦Ù…Ù‡ Ø¨Ø®Ø§ØµÙƒ
       ğŸ“‡ | Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø§Ù„Ø¨ÙˆØª ÙŠØ±Ø³Ù„Ùƒ Ø§Ù„Ù‚Ø§Ø¦Ù…Ù‡ Ù‡Ù†Ø§ ÙÙŠ Ø§Ù„Ø´Ø§Øª**`)
        msg.channel.send(e).then(b => {
            b.react('ğŸ“‡')
            .then(() => b.react('ğŸ“¬'))
            .then(() =>b.react('ğŸ“‡'))
            let reaction1Filter = (reaction, user) => reaction.emoji.name === 'ğŸ“‡' && user.id === msg.author.id;
let reaction2Filter = (reaction, user) => reaction.emoji.name === 'ğŸ“¬' && user.id === msg.author.id;
 
let reaction1 = b.createReactionCollector(reaction1Filter, { time: 12000 });
let reaction2 = b.createReactionCollector(reaction2Filter, { time: 12000 });
reaction1.on("collect", r => {
msg.reply(`
> .bot 
Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ø®
> .server 
Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±
> .bot 
Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ø®
> .skip 
Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§ØºÙ†ÙŠØ© Ø§Ù„ØªØ§Ù„ÙŠØ©
> .stop 
Ù„Ø§ÙŠÙ‚Ø§Ù Ø§ØºÙ†ÙŠØ©
> .play 
Ù„ØªØ´ØºÙŠÙ„ Ø§ØºÙ†ÙŠØ© Ø¨Ø±Ø§Ø¨Ø· Ø§Ùˆ Ø¨Ø§Ø³Ù…
> .support 
Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ
> .id 
Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø­Ø³Ø§Ø¨Ùƒ
> .profile
Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ù…Ø«Ù„ Ø§Ù„ÙÙ„ ÙˆØ§Ù„ÙƒØ±ÙŠØ¯Øª ÙˆØ§Ù„Ø®
> #giveaway 
Ù„ØµÙ†Ø¹ Ø¬ÙŠÙ Ø§ÙˆØ§ÙŠ - Ø§Ø¯Ø§Ø±Ø©
> #kick 
Ù„Ø·Ø±Ø¯ Ø´Ø®Øµ - Ø§Ø¯Ø§Ø±Ø©
> #setlog 
Ù„ÙˆØ¶Ø¹ Ø±ÙˆÙ… Ø§Ù„ÙˆØ¬ - Ø§Ø¯Ø§Ø±Ø©
> #setlog 
Ù„ÙˆØ¶Ø¹ Ø±ÙˆÙ… Ø§Ù„ÙˆØ¬ - Ø§Ø¯Ø§Ø±Ø©
> #ban 
Ù„ØªØ¨Ù†ÙŠØ¯ Ø´Ø®Øµ - Ø§Ø¯Ø§Ø±Ø©
> #role
Ù„ Ø§Ø¹Ø·Ø§Ø¡ Ø´Ø®Øµ Ø±ØªØ¨Ø© - Ø§Ø¯Ø§Ø±Ø©
> #-role 
Ù„Ø³Ø­Ø¨ Ø±ØªØ¨Ø© Ù…Ø­Ø¯Ø¯Ø© Ù…Ù† Ø´Ø®Øµ - Ø§Ø¯Ø§Ø±Ø©
> #clear 
Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Øª - Ø§Ø¯Ø§Ø±Ø©
> #ban 
Ù„Ø³Ø­Ø¨ Ø±ØªØ¨Ø© Ù…Ø­Ø¯Ø¯Ø© Ù…Ù† Ø´Ø®Øµ - Ø§Ø¯Ø§Ø±Ø©
> #autorole toggle on 
ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© - Ø§Ø¯Ø§Ø±Ø©
> #autorole toggle off 
Ø§ØºÙ„Ø§Ù‚ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© - Ø§Ø¯Ø§Ø±Ø©
> #autoset [Role Name]
Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„ØªÙ„Ù‚Ø¦Ø§ÙŠØ© - Ø§Ø¯Ø§Ø±Ø©
> #autoroleinfo
Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„ØªÙ„Ù‚Ø¦Ø§ÙŠØ© - Ø§Ø¯Ø§Ø±Ø©
> #sl
Ù„ÙˆØ¶Ø¹ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙˆØ¯ÙŠØ¹ Ù…Ø¹ Ø§Ù„Ø±ÙˆÙ… - Ø§Ø¯Ø§Ø±Ø©
> #togl
Ù„ØªÙØ¹ÙŠÙ„ , Ø§ØºÙ„Ø§Ù‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙˆØ¯ÙŠØ¹ - Ø§Ø¯Ø§Ø±Ø©
> #togdmwlc
Ù„ØªÙØ¹ÙŠÙ„ , Ø§ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨Ø§Ù„Ø®Ø§Øµ - Ø§Ø¯Ø§Ø±Ø©
> #toginv
Ù„ØªÙØ¹ÙŠÙ„ , Ø§ØºÙ„Ø§Ù‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¯Ø¹ÙˆØ© Ø¨ÙˆØ§Ø³Ø·Ø© - Ø§Ø¯Ø§Ø±Ø©

`)
b.delete(2000)
})
reaction2.on("collect", r => {
    msg.author.send(`
> .bot | Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ø®
> .server | Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±
> .bot | Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙˆØª Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ø®
> .skip | Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø§ØºÙ†ÙŠØ© Ø§Ù„ØªØ§Ù„ÙŠØ©
> .stop | Ù„Ø§ÙŠÙ‚Ø§Ù Ø§ØºÙ†ÙŠØ©
> .play | Ù„ØªØ´ØºÙŠÙ„ Ø§ØºÙ†ÙŠØ© Ø¨Ø±Ø§Ø¨Ø· Ø§Ùˆ Ø¨Ø§Ø³Ù…
> #giveaway | Ù„ØµÙ†Ø¹ Ø¬ÙŠÙ Ø§ÙˆØ§ÙŠ - Ø§Ø¯Ø§Ø±Ø©
> #kick | Ù„Ø·Ø±Ø¯ Ø´Ø®Øµ - Ø§Ø¯Ø§Ø±Ø©
> #ban | Ù„ØªØ¨Ù†ÙŠØ¯ Ø´Ø®Øµ - Ø§Ø¯Ø§Ø±Ø©
`)
    b.delete(2000)
    msg.reply("**ØªÙ… Ø§Ø±Ø³Ø§Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ù‡ ÙÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø¬Ø§Ø­**").then(d => {
        d.delete(2000)
    })
    })
        })
    }
});
/////..../////
client.on('message',async message => {
  var room;
  var title;//HactorMC
  var duration;//HactorMC
  var gMembers;
  var filter = m => m.author.id === message.author.id;
  if(message.content.startsWith(prefix + "giveaway")) {
     //return message.channel.send('**ÙÙŠ Ù…Ø´ÙƒÙ„Ù‡ Ø¨Ø¨Ø¹Ø¶ Ø§Ù„Ø§Ø³Ø§Ø³ÙŠØ§Øª Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ù†ØªØ¸Ø± Ø´ÙˆÙŠ**');
    if(!message.guild.member(message.author).hasPermission('MANAGE_GUILD')) return message.channel.send(':heavy_multiplication_x:| **ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù„Ø¯ÙŠÙƒ Ø®Ø§ØµÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±**');
    message.channel.send(`**Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØ¨ Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø¨Ø¯ÙˆÙ† Ù…Ù†Ø´Ù† ( # )**`).then(msgg => {
      message.channel.awaitMessages(filter, {
        max: 1,//HactorMC
        time: 20000,
        errors: ['time']
      }).then(collected => {
        let room = message.guild.channels.find('name', collected.first().content);
        if(!room) return message.channel.send('**Ù„Ù… Ø§Ù‚Ø¯Ø± Ø¹Ù„ÙŠ Ø§ÙŠØ¬Ø§Ø¯ Ø§Ù„Ø±ÙˆÙ… | Ø§Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ù‡ Ù„Ø§Ø­Ù‚Ø§**');
        room = collected.first().content;
        collected.first().delete();
        msgg.edit('**Ø§ÙƒØªØ¨ Ù…Ø¯Ø© Ø§Ù„Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠ Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚**').then(msg => {
          message.channel.awaitMessages(filter, {
            max: 1,//HactorMC
            time: 20000,
            errors: ['time']
          }).then(collected => {
            if(isNaN(collected.first().content)) return message.channel.send(':heavy_multiplication_x:| **ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù† ØªØ­Ø¯Ø¯ ÙˆÙ‚Øª Ø²Ù…Ù†ÙŠ ØµØ­ÙŠØ­.. ``ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ø¹Ø§Ø¯Ø© ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø§Ù…Ø±``**');
            duration = collected.first().content * 60000;
            collected.first().delete();
            msgg.edit(':eight_pointed_black_star:| **Ø§ÙƒØªØ¨ Ø¹Ù„Ù‰ Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø§Ù„Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠ**').then(msg => {
              message.channel.awaitMessages(filter, {
                max: 1,
                time: 20000,
                errors: ['time']
              }).then(collected => {
                title = collected.first().content;
                collected.first().delete();
                try {
                  let giveEmbed = new Discord.RichEmbed()
                  .setAuthor(message.guild.name, message.guild.iconURL)
                  .setTitle(title)
                  .setDescription(`Ø§Ù„Ù…Ø¯Ø© : ${duration / 60000} Ø¯Ù‚Ø§Ø¦Ù‚`)
                  .setFooter(message.author.username, message.author.avatarURL);
                  message.guild.channels.find('name', room).send(giveEmbed).then(m => {
                     let re = m.react('ğŸ‰');
                     setTimeout(() => {
                       let users = m.reactions.get("ğŸ‰").users;
                       let list = users.array().filter(u => u.id !== m.author.id);
                       let gFilter = list[Math.floor(Math.random() * list.length) + 0];
                         if(users.size === 1) gFilter = '**Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ¯**';
                       let endEmbed = new Discord.RichEmbed()
                       .setAuthor(message.author.username, message.author.avatarURL)
                       .setTitle(title)
                       .addField('Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠ !',`Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ : ${gFilter}`)
                       .setFooter(message.guild.name, message.guild.iconURL);
                       m.edit(endEmbed);
                     },duration);
                   });
                  msgg.edit(`:heavy_check_mark:| **ØªÙ… Ø§Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠ**`);
                } catch(e) {
                  msgg.edit(`:heavy_multiplication_x:| **Ù„Ù… Ø§Ù‚Ø¯Ø± Ø¹Ù„ÙŠ Ø§Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù‚ÙŠÙ Ø§ÙˆØ§ÙŠ Ø¨Ø³Ø¨Ø¨ Ø¹Ø¯Ù… ØªÙˆÙØ± Ø§Ù„Ø¨Ø±Ù…Ø´Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨**`);
                  console.log(e);
                }
              });
            });
          });
        });
      });
    });
  }
});
 var attentions = {};
var times = {
    "1âƒ£": "m",
    "2âƒ£": "h",
    "3âƒ£": "d"
}
var times_ms = {
    "m": 1000 * 60,
    "h": 1000 * 60 * 60,
    "d": 1000 * 60 * 60 * 24
}
var times_name = {
    "m": "Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚",
    "h": "Ø§Ù„Ø³Ø§Ø¹Ø§Øª",
    "d": "Ø§Ù„Ø£ÙŠØ§Ù…"
}
console.log('Alarm Code . By n3k4a');
client.on('message',( message )=>{
      if( message.content.startsWith( prefix + 'alarm' ) ){
        if( attentions[ message.member ] ) {
            message.channel.send( message.member + ', **:timer: Ø£Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø±ÙŠØ«Ù…Ø§ ÙŠØªÙ… Ø£Ø¹Ø¯Ø§Ø¯Ùƒ**').then( (m) =>{
                m.react('1âƒ£').then( r1 => {
                    m.react('2âƒ£').then( r2 => {
                        setTimeout(function ( ){
                            m.edit( message.member +', ** ÙŠÙˆØ¬Ø¯ ØªØ°ÙƒÙŠØ± Ù…Ø¶Ø§Ù Ø¨Ø§Ù„ÙØ¹Ù„, Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ø°ÙÙ‡ ØŸ ** \n**:one: Ù†Ø¹Ù…** \n **:two: Ù„Ø§** ' );
                            m.awaitReactions((reaction, user) => user.id == message.author.id, {time: 60000, maxEmojis: 1})
                            .then(result => {
                                var reaction = result.firstKey();
                                if( reaction == "1âƒ£" || reaction == "2âƒ£" ){
                                    if( reaction == "1âƒ£" ){
                                        clearTimeout(attentions[message.member]['timer']);
                                        attentions[message.member] = undefined;
                                        m.edit(message.member + '**:white_check_mark: ØªÙ… Ø­Ø°Ù Ø§Ù„ØªØ°ÙƒÙŠØ±, ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø£Ø¶Ø§ÙØ© ÙˆØ§Ø­Ø¯**');
                                    } else if( reaction == "2âƒ£" ){
                                        m.edit(message.member + '** Ù„Ù† ÙŠØªÙ… Ø­Ø°Ù Ø§Ù„ØªØ°ÙƒÙŠØ± **')
                                    }
                                    m.Reactions();
                                }
                            });
                        },1000);
                    });
                });
            });

        } else {
            attentions[message.member] = { };
            message.channel.send( message.member + ', **:timer: Ø£Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø±ÙŠØ«Ù…Ø§ ÙŠØªÙ… Ø£Ø¹Ø¯Ø§Ø¯Ùƒ**').then( (m) =>{
                m.edit( message.member + ', **:writing_hand: Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø§Ù† ÙŠÙƒÙˆÙ† Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªØ°ÙƒÙŠØ± **' )
                m.channel.awaitMessages( m1 => m1.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m1) => {
                    m1 = m1.first();
                    attentions[message.member]['title'] = m1.content;
                    m1.delete();
                    m.edit(message.member + ', **:timer: Ø£Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø±ÙŠØ«Ù…Ø§ ÙŠØªÙ… Ø£Ø¹Ø¯Ø§Ø¯Ùƒ**').then( (m) =>{
                        m.edit( message.member + ', **:writing_hand: Ù…Ø§Ø°Ø§ ØªØ±ÙŠØ¯ Ø§Ù† ÙŠÙƒÙˆÙ† ÙˆØµÙ Ø§Ù„ØªØ°ÙƒÙŠØ± **' )
                        m.channel.awaitMessages( m2 => m2.author == message.author,{ maxMatches: 1, time: 60*1000 } ).then ( (m2) => {
                            m2 = m2.first();
                            attentions[message.member]['desc'] = m2.content;
                            m2.delete()
                            m.edit(message.member + ', **:timer: Ø£Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø±ÙŠØ«Ù…Ø§ ÙŠØªÙ… Ø£Ø¹Ø¯Ø§Ø¯Ùƒ**').then( ()=>{
                                m.react('1âƒ£').then( r1 => {
                                    m.react('2âƒ£').then( r2 => {
                                        m.react('3âƒ£').then( r2 => {
                                            setTimeout(function ( ){
                                                m.edit(message.member + ', **:writing_hand: Ø­Ø¯Ø¯ Ù…ÙˆØ¹Ø¯ Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠ**\n **:one: Ø¨Ø¹Ø¯ Ø¯Ù‚Ø§Ø¦Ù‚ ** \n **:two: Ø¨Ø¹Ø¯ Ø³Ø§Ø¹Ø§Øª ** \n **:three: Ø¨Ø¹Ø¯ Ø£ÙŠØ§Ù…**');
                                                m.awaitReactions((reaction, user) => user.id == message.author.id, {time: 60000, maxEmojis: 1})
                                                    .then(result => {
                                                        var reaction = result.firstKey();
                                                        if( reaction == "1âƒ£" || reaction == "2âƒ£" || reaction == "3âƒ£" ){
                                                            attentions[message.member]['time'] = times_ms[times[reaction]];
                                                            m.edit(message.member + ', **:timer: Ø£Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø±ÙŠØ«Ù…Ø§ ÙŠØªÙ… Ø£Ø¹Ø¯Ø§Ø¯Ùƒ**').then ( ( ) =>{
                                                            m.clearReactions().then( () =>{
                                                                m.edit(message.member + ', **:timer: Ø§Ø°ÙƒØ± Ø¹Ø¯Ø¯ '+times_name[times[reaction]]+'**' )
                                                                    m.channel.awaitMessages( m3 => m3.author == message.author && !isNaN(m3.content),{ maxMatches: 1, time: 60*1000 } ).then ( (m3) => {
                                                                        m3 = m3.first();
                                                                        attentions[message.member]['time_num'] = m3.content;
                                                                        m3.delete();
                                                                        attentions[message.member]['timer'] = setTimeout(function( ){
                                                                            message.member.send('** '+message.member+' ØªØ°ÙƒÙŠØ± !! **')
                                                                            var embed = new Discord.RichEmbed( );
                                                                            embed.setTitle( attentions[message.member]['title'] );
                                                                            embed.setDescription( attentions[message.member]['desc'] );
                                                                            embed.setTimestamp();
                                                                            message.member.send({embed});
                                                                            message.member.send('** '+message.member+' ØªØ°ÙƒÙŠØ± !! **')
                                                                        }, attentions[message.member]['time_num'] * attentions[message.member]['time'] );

                                                                        message.reply('** :white_check_mark: ØªÙ… Ø£Ø¶Ø§ÙØ© Ø§Ù„ØªØ°ÙƒÙŠØ±, Ø³ÙŠØªÙ… ØªØ°ÙƒÙŠØ±Ùƒ Ù„Ø§Ø­Ù‚Ø§Ù‹ **');
                                                                        m.delete();
                                                                        message.delete();
                                                                    }).catch(function(){ m.delete( ); attentions[message.member] = undefined; } );
                                                                });
                                                            });
                                                        }
                                                    });
                                            },1000);
                                        });
                                    });
                                });
                            }).catch(function() { m.delete();attentions[message.member] = undefined;  });
                        }).catch(function() { m.delete(); attentions[message.member] = undefined;  });
                    });

                }).catch(function( ) {m.delete(); attentions[message.member] = undefined; });
            });
        }
    }
});
const db = require("quick.db");
client.on("message", async message => {
if(message.author.bot || message.channel.type === "dm") return undefined;
let args = message.content.split(' ');
if(args[0].toLowerCase() == `${prefix}register`) {
db.fetch(`registerid${message.author.id}`)
db.fetch(`registername${message.author.id}`)
db.fetch(`registerage${message.author.id}`)
db.fetch(`registercountry${message.author.id}`)
db.fetch(`registercode${message.author.id}`)
db.fetch(`registerdata${message.author.id}`)
db.fetch(`registerchannel${message.author.id}`)
let name = message.content.split(" ")[1];
let age = message.content.split(" ")[2];
let country = message.content.split(" ")[3];
if(db.fetch(`registerid${message.author.id}`) === null || db.fetch(`registername${message.author.id}`) === null || db.fetch(`registerage${message.author.id}`) === null || db.fetch(`registercountry${message.author.id}`) === null || db.fetch(`registercode${message.author.id}`) || db.fetch(`registerdata${message.author.id}`) === null || db.fetch(`registerchannel${message.author.id}`) === null) return undefined;
if(!name || !age || !country) return message.channel.send(`**ğŸ’¡ | Using: \`\`${prefix}register <name> <age> <country>\`\`**`)
let ss = Math.floor((Math.random() * 1000) + 1);
message.channel.send(`**âœ… | Done**`)
let e = new Discord.RichEmbed()
.setAuthor(message.author.tag)
.setThumbnail(message.author.avatarURL)
.setDescription(`âœ¨ | ${message.author}
**Name;** ${name}
**Age;** ${age}
**Country;** ${country}
**Date;** ${moment().format('llll')}
**Registration in;** ${message.channel}
**Code;** ${ss}
\`\`\`
UserID; ${message.author.id} 
\`\`\``)
client.channels.get("Ø§ÙƒØªØ¨ Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ ÙŠÙˆØµÙ„ ÙÙŠÙ‡ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª").send(e)
db.set(`registerid${message.author.id}`, message.author.id)
db.set(`registername${message.author.id}`, name)
db.set(`registerage${message.author.id}`, age)
db.set(`registercountry${message.author.id}`, country)
db.set(`registercode${message.author.id}`, ss)
db.set(`registerdata${message.author.id}`, moment().format('llll'))
db.set(`registerchannel${message.author.id}`, message.channel.id)
}
})

client.on("message", async message => {
if(message.author.bot || message.channel.type === "dm") return undefined;
let args = message.content.split(' ');
if(args[0].toLowerCase() == `${prefix}getinfo`) {
let user = message.mentions.users.first()
let e = new Discord.RichEmbed()
.setAuthor(user.tag)
.setThumbnail(user.avatarURL)
.setDescription(`âœ¨ | ${user}
**Name;** ${db.fetch(`registerid${user.id}`)}
**Age;** ${db.fetch(`registerage${user.id}`)}
**Country;** ${db.fetch(`registercountry${user.id}`)}
**Date;** ${db.fetch(`registerdata${user.id}`)}
**Registration in;** <#${db.fetch(`registerchannel${user.id}`)}>
**Code;** ${db.fetch(`registercode${user.id}`)}
\`\`\`
UserID; ${user.id} 
\`\`\``)
message.channel.send(e)
}
})
////if(!message.author.id === 'Ø§ÙŠ Ø¯ÙŠ ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª') return;
client.on('message', message => {
    if(message.content == prefix + 'slist') {
             if(!message.author.id === '323885452207587329') return;
             if(!message.author.id === '334435543851204618') return;
    var gimg;
    var gname;
    var gmemb;
    var gbots;
    var groles;
    var servers = client.guilds;
    servers.forEach((g)=>{
    gname = g.name;
    gimg = g.iconURL;
    gmemb = g.members.size;
    let serv = new Discord.RichEmbed()
    .setAuthor(gname,gimg)
    .setThumbnail(gimg)
    .addField('Server Member Count',gmemb = g.members.size)
    .setColor('RANDOM')
    message.channel.send(`
    
            `);
          message.channel.sendEmbed(serv);
    }) 
    }
    });
    
    client.on('message', message => {
    if(message.content == prefix + 'slis') {
             if(!message.author.id === '323885452207587329') return;
             if(!message.author.id === '334435543851204618') return;
    var gimg;
    var gname;
    var gmemb;
    var gbots;
    var groles;
    var servers = client.guilds;
    servers.forEach((g)=>{
    gname = g.name;
    gimg = g.iconURL;
    gmemb = g.members.size;
    let serv = new Discord.RichEmbed()
    message.channel.send(`
    **-------------------------**
      Server Name : **${gname}**
      Server MemberCount : **${gmemb} **
      **---------------------------**
            `);
    }) 
    }
    });
client.on('guildMemberAdd', member => {
    let channel = member.guild.channels.find('name', 'ãƒ»text');
    let memberavatar = member.user.avatarURL
      if (!channel) return; 
    let embed = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setThumbnail(memberavatar)
        .addField(':running_shirt_with_sash: | name :  ',`${member}`)
        .addField(':loudspeaker: | Ù†ÙˆØ±Øª Ø§Ù„Ø³ÙŠØ±ÙØ± ÙŠ Ù‚Ù„Ø¨ÙŠ' , `Welcome to the server, ${member}`)
        .addField(':id: | user :', "**[" + `${member.id}` + "]**" )
                .addField('â¡| Ø§Ù†Øª Ø§Ù„Ø¹Ø¶Ùˆ Ø±Ù‚Ù…',`${member.guild.memberCount}`)
               
                  .addField("Name:",`<@` + `${member.id}` + `>`, true)
                      
                                     .addField(' Ø§Ù„Ù€Ø³ÙŠØ±ÙØ±', `${member.guild.name}`,true)
                                       
     .setFooter("Arab Dark Gaming .")
        .setTimestamp()
    
      channel.sendEmbed(embed);
    });
    client.on('message', message => {
    if (message.content.startsWith(".stats")) {
    message.channel.send({
        embed: new Discord.RichEmbed()
            .addField('Uptime', timeCon(process.uptime()), true)
            .addField('RAM Usage', `${(process.memoryUsage().rss / 1048576).toFixed()}MB`, true)
            .addField('Guild Count', client.guilds.size, true)
    })
}
});

function timeCon(time) {
    let days = Math.floor(time % 31536000 / 86400)
    let hours = Math.floor(time % 31536000 % 86400 / 3600)
    let minutes = Math.floor(time % 31536000 % 86400 % 3600 / 60)
    let seconds = Math.round(time % 31536000 % 86400 % 3600 % 60)
    days = days > 9 ? days : '0' + days
    hours = hours > 9 ? hours : '0' + hours
    minutes = minutes > 9 ? minutes : '0' + minutes
    seconds = seconds > 9 ? seconds : '0' + seconds
    return `${days > 0 ? `${days}:` : ''}${(hours || days) > 0 ? `${hours}:` : ''}${minutes}:${seconds}`
}
const random = require('random');

const jsonfile = require('jsonfile');





var stats = {};

if (fs.existsSync('stats.json')) {

    stats = jsonfile.readFileSync('stats.json');

}


client.on('message', (message) => {

    if (message.author.id == client.user.id)

        return;


    if (message.guild.id in stats === false) {

        stats[message.guild.id] = {};

    }


    const guildStats = stats[message.guild.id];

    if (message.author.id in guildStats === false) {

        guildStats[message.author.id] = {

            xp: 0,

            level: 0,

            last_message: 0

        };

    }


    const userStats = guildStats[message.author.id];

    if (Date.now() - userStats.last_message > 60000) {

        userStats.xp += random.int(15, 25);

        userStats.last_message = Date.now();


        const xpToNextLevel = 5 * Math.pow(userStats.level, 2) + 50 * userStats.level + 100;

        if (userStats.xp >= xpToNextLevel) {

            userStats.level++;

            userStats.xp = userStats.xp - xpToNextLevel;

            message.channel.send(message.author + ' has reached level ' + userStats.level);

        }


        jsonfile.writeFileSync('stats.json', stats);


        console.log(message.author.username + ' now has ' + userStats.xp);

        console.log(xpToNextLevel + ' XP needed for next level.');

    }


    const parts = message.content.split(' ');


    if(parts[0] === '!hello') {

        message.reply('hi');

    }

});
client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});
         client.on('message', message => {
            if (message.content === 'tt') {
              message.channel.send('');
              message.channel.sendFile("https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fhh.jpg");
               

            }
});
client.on('message', message => {
var prefix = "#";
if(message.channel.type === "dm") return;
if(message.author.bot) return;
  if(!sWlc[message.guild.id]) sWlc[message.guild.id] = {
    channel: "welcome"
}
const channel = sWlc[message.guild.id].channel
  if (message.content.startsWith(prefix + "sw")) {
    if(!message.member.hasPermission(`MANAGE_GUILD`)) return;
    let newChannel = message.content.split(' ').slice(1).join(" ")
    if(!newChannel) return message.reply(`**${prefix}setwelcomer <channel name>**`)
    sWlc[message.guild.id].channel = newChannel
    message.channel.send(`**${message.guild.name}'s channel has been changed to ${newChannel}**`);
  }
});
const sWlc = {}
client.on("guildMemberAdd", member => {
      if(!sWlc[member.guild.id]) sWlc[member.guild.id] = {
    channel: "new"
  }
  const channel = sWlc[member.guild.id].channel
    const sChannel = sWlc[member.guild.id].channel
    let welcomer = member.guild.channels.find('name', sChannel);
    let memberavatar = member.user.avatarURL
      if (!welcomer) return;
      if(welcomer) {
         moment.locale('ar-ly');
         var h = member.user;
        //let heroo = new Discord.RichEmbed()
        //.setColor('RANDOM')
        //.setThumbnail(h.avatarURL)
         //.setAuthor(h.username,h.avatarURL)
        //.addField(': ØªØ§Ø±ÙŠØ® Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø¯Ø³ÙƒÙˆØ±Ø¯',`${moment(member.user.createdAt).format('D/M/YYYY h:mm a')} **\n** \`${moment(member.user.createdAt).fromNow()}\``,true)            
        //.addField(': ØªØ§Ø±ÙŠØ® Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø³ÙŠØ±ÙØ±',`${moment(member.joinedAt).format('D/M/YYYY h:mm a ')} \n\`\`${moment(member.joinedAt).startOf(' ').fromNow()}\`\``, true)      
        //.setFooter(`${h.tag}`,"https://images-ext-2.discordapp.net/external/JpyzxW2wMRG2874gSTdNTpC_q9AHl8x8V4SMmtRtlVk/https/orcid.org/sites/default/files/files/ID_symbol_B-W_128x128.gif")
     //welcomer.send({embed:heroo});          
         
      var Canvas = require('canvas')
      var jimp = require('jimp')
     const w = ["https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fswlc.png"];
      
              let Image = Canvas.Image,
                  canvas = new Canvas.Canvas(557, 241),
                  ctx = canvas.getContext('2d');
  
              fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
                  if (err) return console.log(err)
                  let BG = Canvas.Image;
                  let ground = new Image;
                  ground.src = Background;
                  ctx.drawImage(ground, 0, 0, 557, 241);
      
      })
      
                      let url = member.user.displayAvatarURL.endsWith(".webp") ? member.user.displayAvatarURL.slice(5, -20) + ".gif" : member.user.displayAvatarURL;
                      jimp.read(url, (err, ava) => {
                          if (err) return console.log(err);
                          ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                              if (err) return console.log(err);
      
                                    ctx.font = '30px Arial Bold';
                              ctx.fontSize = '20px';
                              ctx.fillStyle = "#FFFFFF";
                                ctx.fillText(member.user.username, 245, 150);
                              
                              //NAMEÙ‹
                              ctx.font = '30px Arial';
                              ctx.fontSize = '28px';
                              ctx.fillStyle = "#FFFFFF";
      ctx.fillText(`Welcome To Server`, 245, 80);
    
                              //AVATARÙ‹
                              let Avatar = Canvas.Image;
                              let ava = new Avatar;
                              ava.src = buf;
                              ctx.beginPath();
                 ctx.arc(120.8, 120.5, 112.3, 0, Math.PI*2, true);
                   ctx.closePath();
                   
                                 ctx.clip();

                        ctx.drawImage(ava, 7, 8, 227, 225);
                              ctx.closePath();

                            
    welcomer.sendFile(canvas.toBuffer())
      
      
      
      })
      })
      
      }
      });
/////////////////////////////////
      client.on('guildMemberAdd', member => {
      const welcomer =  member.guild.channels.find('name', 'nmmkkd');//Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ÙŠØ±Ø­Ø¨ ÙÙŠÙ‡

      var Canvas = require('canvas')
      var jimp = require('jimp')

      const w = ["https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fw1.png",
      "https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fw2.png",
      "https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fw3.png",
      "https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fw4.png",
      "https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fw5.png",
      "https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fw6.png",
      "https://cdn.glitch.com/aa707a85-baa9-422e-9d82-952081ae50ef%2Fw7.png"];

              let Image = Canvas.Image,
                  canvas = new Canvas.Canvas(401, 202),
                  ctx = canvas.getContext('2d');
              ctx.patternQuality = 'bilinear';
              ctx.filter = 'bilinear';
              ctx.antialias = 'subpixel';
              ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
              ctx.shadowOffsetY = 2;
              ctx.shadowBlur = 2;
              fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
                  if (err) return console.log(err)
                  let BG = Canvas.Image;
                  let ground = new Image;
                  ground.src = Background;
                  ctx.drawImage(ground, 0, 0, 401, 202);

      })

                      let url = member.user.displayAvatarURL.endsWith(".webp") ? member.user.displayAvatarURL.slice(5, -20) + ".gif" : member.user.displayAvatarURL;
                      jimp.read(url, (err, ava) => {
                          if (err) return console.log(err);
                          ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                              if (err) return console.log(err);

                              
                              let Avatar = Canvas.Image;
                              let ava = new Avatar;
                              ava.src = buf;
                              ctx.drawImage(ava, 152, 27, 95, 95);

                                                      //wl
                              ctx.font = '20px Arial Bold';
                              ctx.fontSize = '15px';
                              ctx.fillStyle = "#FFFFFF";
                              ctx.textAlign = "center";
                                                         ctx.fillText(member.user.username, 200, 154);

                              //NAME
                              ctx.font = '20px Arial';
                              ctx.fontSize = '28px';
                              ctx.fillStyle = "#FFFFFF";
                              ctx.textAlign = "center";
                                    ctx.fillText(`You Are Number ${member.guild.memberCount} `
                              , 200, 190);

 welcomer.sendFile(canvas.toBuffer())



      })
      })
      });
///////////////////
client.on("message", message => {
	var prefix = "#";
	var args = message.content.split(' ').slice(1); 
	var msg = message.content.toLowerCase();
	if( !message.guild ) return;
	if(!msg.startsWith( prefix + "role")) return;
	if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(' **__Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª__**');
	if( msg.toLowerCase().startsWith( prefix + 'roleremove' ) ){
		if( !args[0] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨ Ù…Ù†Ù‡ Ø§Ù„Ø±ØªØ¨Ø©**' );
		if( !args[1] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**' );
		var role = msg.split(' ').slice(2).join(" ").toLowerCase(); 
		var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first(); 
		if( !role1 ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**' );if( message.mentions.members.first() ){
			message.mentions.members.first().removeRole( role1 );
			return message.reply('**:white_check_mark: [ '+role1.name+' ] Ø±ØªØ¨Ø© [ '+args[0]+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† **');
		}
		if( args[0].toLowerCase() == "all" ){
			message.guild.members.forEach(m=>m.removeRole( role1 ))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "bots" ){
			message.guild.members.filter(m=>m.user.bot).forEach(m=>m.removeRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "humans" ){
			message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.removeRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**');
		} 	
	} else {
		if( !args[0] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ø§Ù„Ø±ØªØ¨Ø©**' );
		if( !args[1] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**' );
		var role = msg.split(' ').slice(2).join(" ").toLowerCase(); 
		var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first(); 
		if( !role1 ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**' );if( message.mentions.members.first() ){
			message.mentions.members.first().addRole( role1 );
			return message.reply('**:white_check_mark: [ '+role1.name+' ] Ø±ØªØ¨Ø© [ '+args[0]+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ **');
		}
		if( args[0].toLowerCase() == "all" ){
			message.guild.members.forEach(m=>m.addRole( role1 ))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "bots" ){
			message.guild.members.filter(m=>m.user.bot).forEach(m=>m.addRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "humans" ){
			message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.addRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**');
		} 
	} 
});
client.on('message', message => {
    if (message.content === "#rooms") {
        if (message.author.bot) return
                      if (!message.guild) return;

        var channels = message.guild.channels.map(channels => `${channels.name}, `).join(' ')
        const embed = new Discord.RichEmbed()
        .setColor('RANDOM')
        .addField(`${message.guild.name}`,`Rooms <a:loading:701122395590623334>`)
        .addField('<a:er:701116095188303903> Rooms Number. <a:down:701121627647377414> : ',`** ${message.guild.channels.size}**`)
        
.addField('<a:er:701116095188303903> Rooms  Name. <a:down:701121627647377414> : ',`**[${channels}]**`)
        message.channel.sendEmbed(embed);
    }
});
var AsciiTable = require('ascii-data-table').default
client.on('message', message =>{
    if(message.content == "#roles"){
        var 
        ros=message.guild.roles.size,
        data = [['Rank', 'RoleName']]
        for(let i =0;i<ros;i++){
            if(message.guild.roles.array()[i].id !== message.guild.id){
         data.push([i,`${message.guild.roles.filter(r => r.position == ros-i).map(r=>r.name)}`])
        }}
        let res = AsciiTable.table(data)

        message.channel.send(`${res}`);
    }
});
const completemsg = `Thank you for agreeing to the rules and code of conduct! You are now a verified member of the guild! \nFeel free to choose what roles youâ€™d like, introduce yourself or check out a our other channels. \n\n**Your unique token is your signature that you have read and understood our rules.**\n`

const shortcode = (n) => {
    const possible = 'ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghjklmnopqrstuvwxyz0123456789'
    let text = ''
    for (var i = 0; i < n + 1; i++) text += possible.charAt(Math.floor(Math.random() * possible.length))
    return text;
}
const config = require('./botconfig.json')
client.on('ready', () => {
    client.user.setActivity(config.playing)
    console.log(`[VERIFYBOT] Connected as ${client.user.username}#${client.user.discriminator} ${client.user.id}`)
})

client.on('guildMemberAdd', (member) => {
    if (member.user.bot || member.guild.id !== config.guild) return
    const token = shortcode(8)
    const welcomemsg = `Welcome to the guild! We hope you find a home here! Check out the \`#general\` channel to make sure that we jive, and as long as our goals are similar, then thereâ€™s a place at the table waiting for you. \n\n If you accept the code of conduct, please verify your agreement by replying to **this DM** with the verification phrase: \n\n\`I agree to abide by all rules. My token is ${token}.\`\n\n **This message is case-sensitive, and please include the period at the end! ** \n\nQuestions? Get at a staff member in the server or via DM.`
    console.log(`${member.user.username}#${member.user.discriminator} joined! CODE: "${token}"`)
    member.send(welcomemsg)
    member.user.token = token
})

const verifymsg = 'I agree to abide by all rules. My token is {token}.'

client.on('message', (message) => {
    if (message.author.bot || !message.author.token || message.channel.type !== `dm`) return
    if (message.content !== (verifymsg.replace('{token}', message.author.token))) return
    message.channel.send({
        embed: {
            color: Math.floor(Math.random() * (0xFFFFFF + 1)),
            description: completemsg,
            timestamp: new Date(),
            footer: {
                text: `Verification Success`
            }
        }
    })
    client.guilds.get(config.guild).member(message.author).roles.add(config.role) // ensure this is a string in the config ("")
        .then(console.log(`TOKEN: ${message.author.token} :: Role ${config.role} added to member ${message.author.id}`))
        .catch(console.error)
})

client.on('disconnect', (event) => {
    setTimeout(() => client.destroy().then(() => client.login(config.token)), 10000)
    console.log(`[DISCONNECT] Notice: Disconnected from gateway with code ${event.code} - Attempting reconnect.`)
})

client.on('reconnecting', () => {
    console.log(`[NOTICE] ReconnectAction: Reconnecting to Discord...`)
})

client.on('error', console.error)
client.on('warn', console.warn)

process.on('unhandledRejection', (error) => {
    console.error(`Uncaught Promise Error: \n${error.stack}`)
})

process.on('uncaughtException', (err) => {
    let errmsg = (err ? err.stack || err : '').toString().replace(new RegExp(`${__dirname}/`, 'g'), './')
    console.error(errmsg)
})
client.on('message', async message =>{
  if (message.author.boss) return;
	var prefix = "#";

if (!message.content.startsWith(prefix)) return;
	let command = message.content.split(" ")[0];
	 command = command.slice(prefix.length);
	let args = message.content.split(" ").slice(1);
	if (command == "mute") {
		if (!message.channel.guild) return;
		if(!message.guild.member(message.author).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª !! ").then(msg => msg.delete(5000));
		if(!message.guild.member(client.user).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù„Ø¨ÙˆØª Ù„Ø§ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª ").then(msg => msg.delete(5000));;
		let user = message.mentions.users.first();
		let muteRole = message.guild.roles.find("name", "Muted");
		if (!muteRole) return message.reply("** Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØªØ¨Ø© Ø§Ù„Ù…ÙŠÙˆØª 'Muted' **").then(msg => {msg.delete(5000)});
		if (message.mentions.users.size < 1) return message.reply('** ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‹ **').then(msg => {msg.delete(5000)});
		let reason = message.content.split(" ").slice(2).join(" ");
		message.guild.member(user).addRole(muteRole);
		const muteembed = new Discord.RichEmbed()
		.setColor("RANDOM")
		.setAuthor(`Muted!`, user.displayAvatarURL)
		.setThumbnail(user.displayAvatarURL)
		.addField("**:busts_in_silhouette:  Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**",  '**[ ' + `${user.tag}` + ' ]**',true)
		.addField("**:hammer:  ØªÙ… Ø¨ÙˆØ§Ø³Ø·Ø© **", '**[ ' + `${message.author.tag}` + ' ]**',true)
		.addField("**:book:  Ø§Ù„Ø³Ø¨Ø¨**", '**[ ' + `${reason}` + ' ]**',true)
		.addField("User", user, true)
		message.channel.send({embed : muteembed});
		var muteembeddm = new Discord.RichEmbed()
		.setAuthor(`Muted!`, user.displayAvatarURL)
		.setDescription(`      
${user} Ø§Ù†Øª Ù…Ø¹Ø§Ù‚Ø¨ Ø¨Ù…ÙŠÙˆØª ÙƒØªØ§Ø¨ÙŠ Ø¨Ø³Ø¨Ø¨ Ù…Ø®Ø§Ù„ÙØ© Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ†
${message.author.tag} ØªÙ…Øª Ù…Ø¹Ø§Ù‚Ø¨ØªÙƒ Ø¨ÙˆØ§Ø³Ø·Ø©
[ ${reason} ] : Ø§Ù„Ø³Ø¨Ø¨
Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ ØªÙƒÙ„Ù… Ù…Ø¹ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ†
`)
		.setFooter(`ÙÙŠ Ø³ÙŠØ±ÙØ± : ${message.guild.name}`)
		.setColor("RANDOM")
	user.send( muteembeddm);
  }
if(command === "unmute") {
  if(!message.member.hasPermission("MANAGE_MESSAGES")) return message.channel.sendMessage("**Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ÙÙƒ Ø¹Ù† Ø§Ù„Ø´Ø®Øµ Ù…ÙŠÙˆØª**:x: ").then(m => m.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_MESSAGES")) return message.reply("**Ù…Ø§ Ø¹Ù†Ø¯ÙŠ Ø¨Ø±Ù…Ø´Ù†**").then(msg => msg.delete(6000))

  let toMute = message.guild.member(message.mentions.users.first()) || message.guild.members.get(args[0]);
  if(!toMute) return message.channel.sendMessage("**Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø£ÙˆÙ„Ø§Ù‘**:x: ");

  let role = message.guild.roles.find (r => r.name === "Muted");
  
  if(!role || !toMute.roles.has(role.id)) return message.channel.sendMessage("**Ù„Ù… ÙŠØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ù‡Ø°Ù‡ Ø´Ø®Øµ Ù…ÙŠÙˆØª Ù…Ù† Ø§Ù„Ø£Ø³Ø§Ø³**:x:")

  await toMute.removeRole(role)
  message.channel.sendMessage("**Ù„Ù‚Ø¯ ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù† Ø´Ø®Øµ Ø¨Ù†Ø¬Ø§Ø­**:white_check_mark:");

  return;

  }

});
    client.on('message',function(message) {
  if (message.author.bot) return;
var prefix = "!";
                  if(!message.channel.guild) return;

                    if (message.content === prefix + "members") {
 const embed = new Discord.RichEmbed()

    .setDescription(`**Members info :sparkles:
:green_heart: online:   ${message.guild.members.filter(m=>m.presence.status == 'online').size}
:heart:  dnd:       ${message.guild.members.filter(m=>m.presence.status == 'dnd').size}
:yellow_heart:  idle:     ${message.guild.members.filter(m=>m.presence.status == 'idle').size}
:diamond_shape_with_a_dot_inside:   membersCount:  ${message.guild.memberCount - message.guild.members.filter(m=>m.user.bot).size}
:bulb: bots: ${message.guild.members.filter(m=>m.user.bot).size} **`)
         message.channel.send({embed});

    }
      });  
////////
const log = JSON.parse(fs.readFileSync('./log.json' , 'utf8'));
  client.on('message', message => {
    var prefix = "#";
           if (!message.channel.guild) return;

    let room = message.content.split(" ").slice(1);
    let findroom = message.guild.channels.find('name', `${room}`)
    if(message.content.startsWith(prefix + "setlog")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
if(!room) return message.channel.send('Please Type The Channel Name')
if(!findroom) return message.channel.send('Please Type The Log Channel Name')
let embed = new Discord.RichEmbed()
.setTitle('**Done The Log Code Has Been Setup**')
.addField('Channel:', `${room}`)
.addField('Requested By:', `${message.author}`)
.setThumbnail(message.author.avatarURL)
.setFooter(`${client.user.username}`)
message.channel.sendEmbed(embed)
log[message.guild.id] = {
channel: room,
onoff: 'On'
}
fs.writeFile("./log.json", JSON.stringify(log), (err) => {
if (err) console.error(err)
})
    }})
         
client.on('message', message => {
  
    if(message.content.startsWith(prefix + "toggleLog")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
        if(!log[message.guild.id]) log[message.guild.id] = {
          onoff: 'Off'
        }
          if(log[message.guild.id].onoff === 'Off') return [message.channel.send(`**The log Is __ğğ__ !**`), log[message.guild.id].onoff = 'On']
          if(log[message.guild.id].onoff === 'On') return [message.channel.send(`**The log Is __ğğ…ğ…__ !**`), log[message.guild.id].onoff = 'Off']
          fs.writeFile("./log.json", JSON.stringify(log), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            });
          }
          
        })


client.on('messageDelete', message => {

	if(message.author.bot) return;
	if(message.channel.type === 'dm') return;
	if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!message.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;
				        if(!log[message.guild.id]) log[message.guild.id] = {
          onoff: 'Off'
        }
    if(log[message.guild.id].onoff === 'Off') return;
	var logChannel = message.guild.channels.find(c => c.name === `${log[message.guild.id].channel}`);
	if(!logChannel) return;

	let messageDelete = new Discord.RichEmbed()
	.setTitle('**[MESSAGE DELETE]**')
	.setColor('RED')
	.setThumbnail(message.author.avatarURL)
	.setDescription(`**\n**:wastebasket: Successfully \`\`DELETE\`\` **MESSAGE** In ${message.channel}\n\n**Channel:** \`\`${message.channel.name}\`\` (ID: ${message.channel.id})\n**Message ID:** ${message.id}\n**Sent By:** <@${message.author.id}> (ID: ${message.author.id})\n**Message:**\n\`\`\`${message}\`\`\``)
	.setTimestamp()
	.setFooter(message.guild.name, message.guild.iconURL)

	logChannel.send(messageDelete);
});
client.on('messageUpdate', (oldMessage, newMessage) => {

	if(oldMessage.author.bot) return;
	if(!oldMessage.channel.type === 'dm') return;
	if(!oldMessage.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!oldMessage.guild.member(client.user).hasPermission('MANAGE_MESSAGES')) return;
				        if(!log[oldMessage.guild.id]) log[oldMessage.guild.id] = {
          onoff: 'Off'
        }
    if(log[oldMessage.guild.id].onoff === 'Off') return;
	var logChannel = oldMessage.guild.channels.find(c => c.name === `${log[oldMessage.guild.id].channel}`);
	if(!logChannel) return;

	if(oldMessage.content.startsWith('https://')) return;

	let messageUpdate = new Discord.RichEmbed()
	.setTitle('**[MESSAGE EDIT]**')
	.setThumbnail(oldMessage.author.avatarURL)
	.setColor('BLUE')
	.setDescription(`**\n**:wrench: Successfully \`\`EDIT\`\` **MESSAGE** In ${oldMessage.channel}\n\n**Channel:** \`\`${oldMessage.channel.name}\`\` (ID: ${oldMessage.channel.id})\n**Message ID:** ${oldMessage.id}\n**Sent By:** <@${oldMessage.author.id}> (ID: ${oldMessage.author.id})\n\n**Old Message:**\`\`\`${oldMessage}\`\`\`\n**New Message:**\`\`\`${newMessage}\`\`\``)
	.setTimestamp()
	.setFooter(oldMessage.guild.name, oldMessage.guild.iconURL)

	logChannel.send(messageUpdate);
});


client.on('roleCreate', role => {

	if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
	        if(!log[role.guild.id]) log[role.guild.id] = {
          onoff: 'Off'
        }
    if(log[role.guild.id].onoff === 'Off') return;
	var logChannel = role.guild.channels.find(c => c.name === `${log[role.guild.id].channel}`);
	if(!logChannel) return;

	role.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		let roleCreate = new Discord.RichEmbed()
		.setTitle('**[ROLE CREATE]**')
		.setThumbnail(userAvatar)
		.setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
		.setColor('GREEN')
		.setTimestamp()
		.setFooter(role.guild.name, role.guild.iconURL)

		logChannel.send(roleCreate);
	})
});
client.on('roleDelete', role => {

	if(!role.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!role.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
	        if(!log[role.guild.id]) log[role.guild.id] = {
          onoff: 'Off'
        }
    if(log[role.guild.id].onoff === 'Off') return;
	var logChannel = role.guild.channels.find(c => c.name === `${log[role.guild.id].channel}`);
	if(!logChannel) return;

	role.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		let roleDelete = new Discord.RichEmbed()
		.setTitle('**[ROLE DELETE]**')
		.setThumbnail(userAvatar)
		.setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` Role.\n\n**Role Name:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
		.setColor('RED')
		.setTimestamp()
		.setFooter(role.guild.name, role.guild.iconURL)

		logChannel.send(roleDelete);
	})
});
client.on('roleUpdate', (oldRole, newRole) => {

	if(!oldRole.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!oldRole.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
	        if(!log[oldRole.guild.id]) log[oldRole.guild.id] = {
          onoff: 'Off'
	        }
    if(log[oldRole.guild.id].onoff === 'Off') return;
	var logChannel = oldRole.guild.channels.find(c => c.name === `${log[oldRole.guild.id].channel}`);
	if(!logChannel) return;

	oldRole.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		if(oldRole.name !== newRole.name) {
            if(log[oldRole.guild.id].onoff === 'Off') return;
			let roleUpdateName = new Discord.RichEmbed()
			.setTitle('**[ROLE NAME UPDATE]**')
			.setThumbnail(userAvatar)
			.setColor('BLUE')
			.setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` Role Name.\n\n**Old Name:** \`\`${oldRole.name}\`\`\n**New Name:** \`\`${newRole.name}\`\`\n**Role ID:** ${oldRole.id}\n**By:** <@${userID}> (ID: ${userID})`)
			.setTimestamp()
			.setFooter(oldRole.guild.name, oldRole.guild.iconURL)

			logChannel.send(roleUpdateName);
		}
		if(oldRole.hexColor !== newRole.hexColor) {
			if(oldRole.hexColor === '#000000') {
				var oldColor = '`Default`';
			}else {
				var oldColor = oldRole.hexColor;
			}
			if(newRole.hexColor === '#000000') {
				var newColor = '`Default`';
			}else {
				var newColor = newRole.hexColor;
            }
            if(log[oldRole.guild.id].onoff === 'Off') return;
			let roleUpdateColor = new Discord.RichEmbed()
			.setTitle('**[ROLE COLOR UPDATE]**')
			.setThumbnail(userAvatar)
			.setColor('BLUE')
			.setDescription(`**\n**:white_check_mark: Successfully \`\`EDITED\`\` **${oldRole.name}** Role Color.\n\n**Old Color:** ${oldColor}\n**New Color:** ${newColor}\n**Role ID:** ${oldRole.id}\n**By:** <@${userID}> (ID: ${userID})`)
			.setTimestamp()
			.setFooter(oldRole.guild.name, oldRole.guild.iconURL)

			logChannel.send(roleUpdateColor);
		}
	})
});

client.on('channelCreate', channel => {

	if(!channel.guild) return;
	if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
	        if(!log[channel.guild.id]) log[channel.guild.id] = {
          onoff: 'Off'
        }
    if(log[channel.guild.id].onoff === 'Off') return;
	var logChannel = channel.guild.channels.find(c => c.name === `${log[channel.guild.id].channel}`);
	if(!logChannel) return;

	if(channel.type === 'text') {
		var roomType = 'Text';
	}else
	if(channel.type === 'voice') {
		var roomType = 'Voice';
	}else
	if(channel.type === 'category') {
		var roomType = 'Category';
	}

	channel.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		let channelCreate = new Discord.RichEmbed()
		.setTitle('**[CHANNEL CREATE]**')
		.setThumbnail(userAvatar)
		.setDescription(`**\n**:white_check_mark: Successfully \`\`CREATE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
		.setColor('GREEN')
		.setTimestamp()
		.setFooter(channel.guild.name, channel.guild.iconURL)

		logChannel.send(channelCreate);
	})
});
client.on('channelDelete', channel => {
	if(!channel.guild) return;
	if(!channel.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!channel.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
	        if(!log[channel.guild.id]) log[channel.guild.id] = {
          onoff: 'Off'
        }
    if(log[channel.guild.id].onoff === 'Off') return;
	var logChannel = channel.guild.channels.find(c => c.name === `${log[channel.guild.id].channel}`);
	if(!logChannel) return;

	if(channel.type === 'text') {
		var roomType = 'Text';
	}else
	if(channel.type === 'voice') {
		var roomType = 'Voice';
	}else
	if(channel.type === 'category') {
		var roomType = 'Category';
	}

	channel.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		let channelDelete = new Discord.RichEmbed()
		.setTitle('**[CHANNEL DELETE]**')
		.setThumbnail(userAvatar)
		.setDescription(`**\n**:white_check_mark: Successfully \`\`DELETE\`\` **${roomType}** channel.\n\n**Channel Name:** \`\`${channel.name}\`\` (ID: ${channel.id})\n**By:** <@${userID}> (ID: ${userID})`)
		.setColor('RED')
		.setTimestamp()
		.setFooter(channel.guild.name, channel.guild.iconURL)

		logChannel.send(channelDelete);
	})
});
client.on('channelUpdate', (oldChannel, newChannel) => {
	if(!oldChannel.guild) return;
	        if(!log[oldChannel.guild.id]) log[oldChannel.guild.id] = {
          onoff: 'Off'
        }
    if(log[oldChannel.guild.id].onoff === 'Off') return;
	var logChannel = oldChannel.guild.channels.find(c => c.name === `${log[oldChannel.guild.id].channel}`);
	if(!logChannel) return;

	if(oldChannel.type === 'text') {
		var channelType = 'Text';
	}else
	if(oldChannel.type === 'voice') {
		var channelType = 'Voice';
	}else
	if(oldChannel.type === 'category') {
		var channelType = 'Category';
	}

	oldChannel.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		if(oldChannel.name !== newChannel.name) {
			let newName = new Discord.RichEmbed()
			.setTitle('**[CHANNEL EDIT]**')
			.setThumbnail(userAvatar)
			.setColor('BLUE')
			.setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Name\n\n**Old Name:** \`\`${oldChannel.name}\`\`\n**New Name:** \`\`${newChannel.name}\`\`\n**Channel ID:** ${oldChannel.id}\n**By:** <@${userID}> (ID: ${userID})`)
			.setTimestamp()
			.setFooter(oldChannel.guild.name, oldChannel.guild.iconURL)

			logChannel.send(newName);
		}
		if(oldChannel.topic !== newChannel.topic) {
            if(log[oldChannel.guild.id].onoff === 'Off') return;
			let newTopic = new Discord.RichEmbed()
			.setTitle('**[CHANNEL EDIT]**')
			.setThumbnail(userAvatar)
			.setColor('BLUE')
			.setDescription(`**\n**:wrench: Successfully Edited **${channelType}** Channel Topic\n\n**Old Topic:**\n\`\`\`${oldChannel.topic || 'NULL'}\`\`\`\n**New Topic:**\n\`\`\`${newChannel.topic || 'NULL'}\`\`\`\n**Channel:** ${oldChannel} (ID: ${oldChannel.id})\n**By:** <@${userID}> (ID: ${userID})`)
			.setTimestamp()
			.setFooter(oldChannel.guild.name, oldChannel.guild.iconURL)

			logChannel.send(newTopic);
		}
	})
});


client.on('guildBanAdd', (guild, user) => {

	if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
	        if(!log[user.guild.id]) log[guild.guild.id] = {
          onoff: 'Off'
        }
    if(log[user.guild.id].onoff === 'Off') return;
	var logChannel = guild.channels.find(c => c.name === `${log[guild.guild.id].channel}`);
	if(!logChannel) return;

	guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		if(userID === client.user.id) return;

		let banInfo = new Discord.RichEmbed()
		.setTitle('**[BANNED]**')
		.setThumbnail(userAvatar)
		.setColor('DARK_RED')
		.setDescription(`**\n**:airplane: Successfully \`\`BANNED\`\` **${user.username}** From the server!\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
		.setTimestamp()
		.setFooter(guild.name, guild.iconURL)

		logChannel.send(banInfo);
	})
});
client.on('guildBanRemove', (guild, user) => {
	if(!guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
	        if(!log[guild.guild.id]) log[guild.guild.id] = {
          onoff: 'Off'
        }
    if(log[guild.guild.id].onoff === 'Off') return;
	var logChannel = guild.channels.find(c => c.name === `${log[guild.guild.id].channel}`);
	if(!logChannel) return;

	guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;

		if(userID === client.user.id) return;

		let unBanInfo = new Discord.RichEmbed()
		.setTitle('**[UNBANNED]**')
		.setThumbnail(userAvatar)
		.setColor('GREEN')
		.setDescription(`**\n**:unlock: Successfully \`\`UNBANNED\`\` **${user.username}** From the server\n\n**User:** <@${user.id}> (ID: ${user.id})\n**By:** <@${userID}> (ID: ${userID})`)
		.setTimestamp()
		.setFooter(guild.name, guild.iconURL)

		logChannel.send(unBanInfo);
	})
});

client.on('guildMemberUpdate', (oldMember, newMember) => {
	if(!oldMember.guild) return;
		        if(!log[oldMember.guild.id]) log[oldMember.guild.id] = {
          onoff: 'Off'
        }
    if(log[oldMember.guild.id].onoff === 'Off') return;
	var logChannel = oldMember.guild.channels.find(c => c.name === `${log[oldMember, newMember.guild.id].channel}`);
	if(!logChannel) return;

	oldMember.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userAvatar = logs.entries.first().executor.avatarURL;
		var userTag = logs.entries.first().executor.tag;

		if(oldMember.nickname !== newMember.nickname) {
			if(oldMember.nickname === null) {
				var oldNM = '`Ø§Ø³Ù…Ù‡ Ø§Ù„Ø§ØµÙ„ÙŠ`';
			}else {
				var oldNM = oldMember.nickname;
			}
			if(newMember.nickname === null) {
				var newNM = '`Ø§Ø³Ù…Ù‡ Ø§Ù„Ø§ØµÙ„ÙŠ`';
			}else {
				var newNM = newMember.nickname;
			}

			let updateNickname = new Discord.RichEmbed()
			.setTitle('**[UPDATE MEMBER NICKNAME]**')
			.setThumbnail(userAvatar)
			.setColor('BLUE')
			.setDescription(`**\n**:spy: Successfully \`\`CHANGE\`\` Member Nickname.\n\n**User:** ${oldMember} (ID: ${oldMember.id})\n**Old Nickname:** ${oldNM}\n**New Nickname:** ${newNM}\n**By:** <@${userID}> (ID: ${userID})`)
			.setTimestamp()
			.setFooter(oldMember.guild.name, oldMember.guild.iconURL)

			logChannel.send(updateNickname);
		}
		if(oldMember.roles.size < newMember.roles.size) {
			let role = newMember.roles.filter(r => !oldMember.roles.has(r.id)).first();
					        if(!log[oldMember.guild.id]) log[oldMember.guild.id] = {
          onoff: 'Off'
        }
            if(log[oldMember.guild.id].onoff === 'Off') return;
			let roleAdded = new Discord.RichEmbed()
			.setTitle('**[ADDED ROLE TO MEMBER]**')
			.setThumbnail(oldMember.guild.iconURL)
			.setColor('GREEN')
			.setDescription(`**\n**:white_check_mark: Successfully \`\`ADDED\`\` Role to **${oldMember.user.username}**\n\n**User:** <@${oldMember.id}> (ID: ${oldMember.user.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(roleAdded);
		}
		if(oldMember.roles.size > newMember.roles.size) {
			let role = oldMember.roles.filter(r => !newMember.roles.has(r.id)).first();
					        if(!log[oldMember.guild.id]) log[oldMember.guild.id] = {
          onoff: 'Off'
        }
            if(log[oldMember, newMember.guild.id].onoff === 'Off') return;
			let roleRemoved = new Discord.RichEmbed()
			.setTitle('**[REMOVED ROLE FROM MEMBER]**')
			.setThumbnail(oldMember.guild.iconURL)
			.setColor('RED')
			.setDescription(`**\n**:negative_squared_cross_mark: Successfully \`\`REMOVED\`\` Role from **${oldMember.user.username}**\n\n**User:** <@${oldMember.user.id}> (ID: ${oldMember.id})\n**Role:** \`\`${role.name}\`\` (ID: ${role.id})\n**By:** <@${userID}> (ID: ${userID})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(roleRemoved);
		}
	})
	if(oldMember.guild.owner.id !== newMember.guild.owner.id) {
	  		        if(!log[oldMember.guild.id]) log[oldMember.guild.id] = {
          onoff: 'Off'
        }
        if(log[oldMember, newMember.guild.id].onoff === 'Off') return;
        let newOwner = new Discord.RichEmbed()
		.setTitle('**[UPDATE GUILD OWNER]**')
		.setThumbnail(oldMember.guild.iconURL)
		.setColor('GREEN')
		.setDescription(`**\n**:white_check_mark: Successfully \`\`TRANSFER\`\` The Owner Ship.\n\n**Old Owner:** <@${oldMember.user.id}> (ID: ${oldMember.user.id})\n**New Owner:** <@${newMember.user.id}> (ID: ${newMember.user.id})`)
		.setTimestamp()
		.setFooter(oldMember.guild.name, oldMember.guild.iconURL)

		logChannel.send(newOwner);
	}
});


client.on('voiceStateUpdate', (voiceOld, voiceNew) => {

	if(!voiceOld.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!voiceOld.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;
			        if(!log[voiceOld.guild.id]) log[voiceOld.guild.id] = {
          onoff: 'Off'
        }
    if(log[voiceOld, voiceOld.guild.id].onoff === 'Off') return;
	var logChannel = voiceOld.guild.channels.find(c => c.name === `${log[voiceOld, voiceNew.guild.id].channel}`);
	if(!logChannel) return;

	voiceOld.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userTag = logs.entries.first().executor.tag;
		var userAvatar = logs.entries.first().executor.avatarURL;

		if(voiceOld.serverMute === false && voiceNew.serverMute === true) {
			let serverMutev = new Discord.RichEmbed()
			.setTitle('**[VOICE MUTE]**')
			.setThumbnail('https://images-ext-1.discordapp.net/external/pWQaw076OHwVIFZyeFoLXvweo0T_fDz6U5C9RBlw_fQ/https/cdn.pg.sa/UosmjqDNgS.png')
			.setColor('RED')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverMutev);
		}
		if(voiceOld.serverMute === true && voiceNew.serverMute === false) {
		  			        if(!log[voiceOld.guild.id]) log[voiceOld.guild.id] = {
          onoff: 'Off'
        }
            if(log[voiceOld, voiceOld.guild.id].onoff === 'Off') return;
			let serverUnmutev = new Discord.RichEmbed()
			.setTitle('**[VOICE UNMUTE]**')
			.setThumbnail('https://images-ext-1.discordapp.net/external/u2JNOTOc1IVJGEb1uCKRdQHXIj5-r8aHa3tSap6SjqM/https/cdn.pg.sa/Iy4t8H4T7n.png')
			.setColor('GREEN')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverUnmutev);
		}
		if(voiceOld.serverDeaf === false && voiceNew.serverDeaf === true) {
		  			        if(!log[voiceOld.guild.id]) log[voiceOld.guild.id] = {
          onoff: 'Off'
        }
            if(log[voiceOld, voiceOld.guild.id].onoff === 'Off') return;
			let serverDeafv = new Discord.RichEmbed()
			.setTitle('**[VOICE DEAF]**')
			.setThumbnail('https://images-ext-1.discordapp.net/external/7ENt2ldbD-3L3wRoDBhKHb9FfImkjFxYR6DbLYRjhjA/https/cdn.pg.sa/auWd5b95AV.png')
			.setColor('RED')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverDeafv);
		}
		if(voiceOld.serverDeaf === true && voiceNew.serverDeaf === false) {
		  			        if(!log[voiceOld.guild.id]) log[voiceOld.guild.id] = {
          onoff: 'Off'
        }
            if(log[voiceOld, voiceOld.guild.id].onoff === 'Off') return;
			let serverUndeafv = new Discord.RichEmbed()
			.setTitle('**[VOICE UNDEAF]**')
			.setThumbnail('https://images-ext-2.discordapp.net/external/s_abcfAlNdxl3uYVXnA2evSKBTpU6Ou3oimkejx3fiQ/https/cdn.pg.sa/i7fC8qnbRF.png')
			.setColor('GREEN')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverUndeafv);
		}
	})
	
	if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && voiceNew.voiceChannel && voiceOld.voiceChannel != null) {
	  			        if(!log[voiceOld.guild.id]) log[voiceOld.guild.id] = {
          onoff: 'Off'
        }
        if(log[voiceOld, voiceOld.guild.id].onoff === 'Off') return;
		let voiceLeave = new Discord.RichEmbed()
		.setTitle('**[CHANGED VOICE ROOM]**')
		.setColor('GREEN')
		.setThumbnail(voiceOld.user.avatarURL)
		.setDescription(`**\n**:repeat: Successfully \`\`CHANGED\`\` The Voice Channel.\n\n**From:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**To:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
		.setTimestamp()
		.setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)

		logChannel.send(voiceLeave);
	}
});


client.on('voiceStateUpdate', (voiceOld, voiceNew) => {

	if(!voiceOld.guild.member(client.user).hasPermission('EMBED_LINKS')) return;
	if(!voiceOld.guild.member(client.user).hasPermission('VIEW_AUDIT_LOG')) return;

	var logChannel = voiceOld.guild.channels.find(c => c.name === 'log');
	if(!logChannel) return;

	voiceOld.guild.fetchAuditLogs().then(logs => {
		var userID = logs.entries.first().executor.id;
		var userTag = logs.entries.first().executor.tag;
		var userAvatar = logs.entries.first().executor.avatarURL;

		if(voiceOld.serverMute === false && voiceNew.serverMute === true) {
			let serverMutev = new Discord.RichEmbed()
			.setTitle('**[VOICE MUTE]**')
			.setThumbnail('https://images-ext-1.discordapp.net/external/pWQaw076OHwVIFZyeFoLXvweo0T_fDz6U5C9RBlw_fQ/https/cdn.pg.sa/UosmjqDNgS.png')
			.setColor('RED')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverMutev);
		}
		if(voiceOld.serverMute === true && voiceNew.serverMute === false) {
			let serverUnmutev = new Discord.RichEmbed()
			.setTitle('**[VOICE UNMUTE]**')
			.setThumbnail('https://images-ext-1.discordapp.net/external/u2JNOTOc1IVJGEb1uCKRdQHXIj5-r8aHa3tSap6SjqM/https/cdn.pg.sa/Iy4t8H4T7n.png')
			.setColor('GREEN')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverUnmutev);
		}
		if(voiceOld.serverDeaf === false && voiceNew.serverDeaf === true) {
			let serverDeafv = new Discord.RichEmbed()
			.setTitle('**[VOICE DEAF]**')
			.setThumbnail('https://images-ext-1.discordapp.net/external/7ENt2ldbD-3L3wRoDBhKHb9FfImkjFxYR6DbLYRjhjA/https/cdn.pg.sa/auWd5b95AV.png')
			.setColor('RED')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverDeafv);
		}
		if(voiceOld.serverDeaf === true && voiceNew.serverDeaf === false) {
			let serverUndeafv = new Discord.RichEmbed()
			.setTitle('**[VOICE UNDEAF]**')
			.setThumbnail('https://images-ext-2.discordapp.net/external/s_abcfAlNdxl3uYVXnA2evSKBTpU6Ou3oimkejx3fiQ/https/cdn.pg.sa/i7fC8qnbRF.png')
			.setColor('GREEN')
			.setDescription(`**User:** ${voiceOld} (ID: ${voiceOld.id})\n**By:** <@${userID}> (ID: ${userID})\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannel.id})`)
			.setTimestamp()
			.setFooter(userTag, userAvatar)

			logChannel.send(serverUndeafv);
		}
	})
	if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && !voiceOld.voiceChannel) {
		let voiceJoin = new Discord.RichEmbed()
		.setTitle('**[JOIN VOICE ROOM]**')
		.setColor('GREEN')
		.setThumbnail(voiceOld.user.avatarURL)
		.setDescription(`**\n**:arrow_lower_right: Successfully \`\`JOIN\`\` To Voice Channel.\n\n**Channel:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
		.setTimestamp()
		.setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)

		logChannel.send(voiceJoin);
	}
	if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && !voiceNew.voiceChannel) {
		let voiceLeave = new Discord.RichEmbed()
		.setTitle('**[LEAVE VOICE ROOM]**')
		.setColor('GREEN')
		.setThumbnail(voiceOld.user.avatarURL)
		.setDescription(`**\n**:arrow_upper_left: Successfully \`\`LEAVE\`\` From Voice Channel.\n\n**Channel:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
		.setTimestamp()
		.setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)

		logChannel.send(voiceLeave);
	}
	if(voiceOld.voiceChannelID !== voiceNew.voiceChannelID && voiceNew.voiceChannel && voiceOld.voiceChannel != null) {
		let voiceLeave = new Discord.RichEmbed()
		.setTitle('**[CHANGED VOICE ROOM]**')
		.setColor('GREEN')
		.setThumbnail(voiceOld.user.avatarURL)
		.setDescription(`**\n**:repeat: Successfully \`\`CHANGED\`\` The Voice Channel.\n\n**From:** \`\`${voiceOld.voiceChannel.name}\`\` (ID: ${voiceOld.voiceChannelID})\n**To:** \`\`${voiceNew.voiceChannel.name}\`\` (ID: ${voiceNew.voiceChannelID})\n**User:** ${voiceOld} (ID: ${voiceOld.id})`)
		.setTimestamp()
		.setFooter(voiceOld.user.tag, voiceOld.user.avatarURL)

		logChannel.send(voiceLeave);
	}
});
///////
client.on("message", message => {
	var args = message.content.split(' ').slice(1); 
	var msg = message.content.toLowerCase();
	if( !message.guild ) return;
	if( !msg.startsWith( prefix + 'role' ) ) return;
	if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(' **__Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª__**');
	if( msg.toLowerCase().startsWith( prefix + '-role' ) ){
		if( !args[0] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨ Ù…Ù†Ù‡ Ø§Ù„Ø±ØªØ¨Ø©**' );
		if( !args[1] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**' );
		var role = msg.split(' ').slice(2).join(" ").toLowerCase(); 
		var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first(); 
		if( !role1 ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø³Ø­Ø¨Ù‡Ø§ Ù…Ù† Ø§Ù„Ø´Ø®Øµ**' );if( message.mentions.members.first() ){
			message.mentions.members.first().removeRole( role1 );
			return message.reply('**:white_check_mark: [ '+role1.name+' ] Ø±ØªØ¨Ø© [ '+args[0]+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† **');
		}
		if( args[0].toLowerCase() == "all" ){
			message.guild.members.forEach(m=>m.removeRole( role1 ))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "bots" ){
			message.guild.members.filter(m=>m.user.bot).forEach(m=>m.removeRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "humans" ){
			message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.removeRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**');
		} 	
	} else {
		if( !args[0] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ø§Ù„Ø±ØªØ¨Ø©**' );
		if( !args[1] ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**' );
		var role = msg.split(' ').slice(2).join(" ").toLowerCase(); 
		var role1 = message.guild.roles.filter( r=>r.name.toLowerCase().indexOf(role)>-1 ).first(); 
		if( !role1 ) return message.reply( '**:x: ÙŠØ±Ø¬Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ØªØ¨Ø© Ø§Ù„Ù…Ø±Ø§Ø¯ Ø§Ø¹Ø·Ø§Ø¦Ù‡Ø§ Ù„Ù„Ø´Ø®Øµ**' );if( message.mentions.members.first() ){
			message.mentions.members.first().addRole( role1 );
			return message.reply('**:white_check_mark: [ '+role1.name+' ] Ø±ØªØ¨Ø© [ '+args[0]+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ **');
		}
		if( args[0].toLowerCase() == "all" ){
			message.guild.members.forEach(m=>m.addRole( role1 ))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„ÙƒÙ„ Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "bots" ){
			message.guild.members.filter(m=>m.user.bot).forEach(m=>m.addRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨ÙˆØªØ§Øª Ø±ØªØ¨Ø©**');
		} else if( args[0].toLowerCase() == "humans" ){
			message.guild.members.filter(m=>!m.user.bot).forEach(m=>m.addRole(role1))
			return	message.reply('**:white_check_mark: [ '+role1.name+' ] ØªÙ… Ø§Ø¹Ø·Ø§Ø¡ Ø§Ù„Ø¨Ø´Ø±ÙŠÙŠÙ† Ø±ØªØ¨Ø©**');
		} 
	} 
});
client.on('message', msg => {
  if (msg.author.bot) return;
  if (!msg.content.startsWith(prefix)) return;
  let command = msg.content.split(" ")[0];
  command = command.slice(prefix.length);
  let args = msg.content.split(" ").slice(1);

    if(command === "clear") {
        const emoji = client.emojis.find("name", "wastebasket")
    let textxt = args.slice(0).join("");
    if(msg.member.hasPermission("MANAGE_MESSAGES")) {
    if (textxt == "") {
        msg.delete().then
        msg.channel.bulkDelete(1000).then(m => m.delete(3000));
} else {
    msg.delete().then
    msg.delete().then
    msg.channel.bulkDelete(textxt);
        msg.channel.send("```php\nØ¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ ØªÙ… Ù…Ø³Ø­Ù‡Ø§: " + textxt + "\n```").then(m => m.delete(3000));
        }    
    }
}
});
client.on('message', message => {
  if (message.content === ".support") {
  let embed = new Discord.RichEmbed()
.setAuthor(message.author.username)
.setColor("#9B59B6")
.addField(" ** :gear: Server Support :gear: **" , "  **https://discord.gg/hcR4MU**")
  
  
message.channel.sendEmbed(embed);
 }
});
const ytdl = require("ytdl-core");
const { Util } = require('discord.js');
const getYoutubeID = require('get-youtube-id');
const fetchVideoInfo = require('youtube-info');
const YouTube = require('simple-youtube-api');
const youtube = new YouTube("AIzaSyAdORXg7UZUo7sePv97JyoDqtQVi3Ll0b8");
let profile = JSON.parse(fs.readFileSync("profile.json", "utf8"))
const dateFormat = require('dateformat');
const Canvas = require("canvas"); 
const id = JSON.parse(fs.readFileSync("./id/rank.json", "utf8"));
const antihack = JSON.parse(fs.readFileSync('./antihack.json' , 'utf8'));
const antijoin = JSON.parse(fs.readFileSync('./antijoin.json' , 'utf8'));
let antibots = JSON.parse(fs.readFileSync('./antibots.json' , 'utf8'));
const jimp = require("jimp"); 
const queue = new Map();
    client.on("message", message => {
  if (message.author.bot) return;
    if(!message.channel.guild) return;
      
if (message.content.startsWith(prefix + "profile")) {
                               let user = message.mentions.users.first();
         var men = message.mentions.users.first();
            var heg;
            if(men) {
                heg = men
            } else {
                heg = message.author
            }
          var mentionned = message.mentions.members.first();
             var h;
            if(mentionned) {
                h = mentionned
            } else {
                h = message.member
            }
            var ment = message.mentions.users.first();
            var getvalueof;
            if(ment) {
              getvalueof = ment;
            } else {
              getvalueof = message.author;
            }
   var mentionned = message.mentions.users.first();
 
    var client;
      if(mentionned){
          var client = mentionned;
      } else {
          var client = message.author;
 
      }
if (!profile[getvalueof.id]) profile[getvalueof.id] = {points: 0,reps: "NOT YET",credits: 1, level: 1,tite: "HypeLC User", rep: 0, lastDaily: "NOT COLLECTED"};
            let Image = Canvas.Image,
            canvas = new Canvas.Canvas(300, 300),
            ctx = canvas.getContext('2d');
            fs.readFile("Super.png", function (err, Background) { //Ø§Ù…ØªØ¯Ø§Ø¯ Ø§Ù„ØµÙˆØ±Ø©
            if (err) return console.log(err);
            let BG = Canvas.Image;
            let ground = new Image;
            ground.src = Background;
            ctx.drawImage(ground, 0, 0, 300, 300); // Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø©
 
})
 
 
 
                let url = getvalueof.displayAvatarURL.endsWith(".webp") ? getvalueof.displayAvatarURL.slice(5, -20) + ".png" : getvalueof.displayAvatarURL;
                jimp.read(url, (err, ava) => {
                    if (err) return console.log(err);
                    ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                        if (err) return console.log(err);
 
                        //ur name
                        ctx.font = 'bold 16px kathen'; // Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ùˆ Ù†ÙˆØ¹Ù‡
                        ctx.fontSize = '40px'; // Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·
                        ctx.fillStyle = "#000000"; // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
                        ctx.textAlign = "center"; // Ù…Ø­Ø§Ø°Ø§ Ø© Ø§Ù„Ù†Øµ
                        ctx.fillText(`${getvalueof.username}`, 153, 173) // Ø§Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ø³Ù…Ùƒ
 
                        //ur name
                        ctx.font = 'bold 16px kathen'; // Ø­Ø¬Ù… Ø§Ù„Ø®Ø· Ùˆ Ù†ÙˆØ¹Ù‡
                        ctx.fontSize = '40px'; // Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·
                        ctx.fillStyle = "#f1f1f1"; // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
                        ctx.textAlign = "center"; // Ù…Ø­Ø§Ø°Ø§ Ø© Ø§Ù„Ù†Øµ
                        ctx.fillText(`${getvalueof.username}`, 151, 171) // Ø§Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ø³Ù…Ùƒ
 
                        //credit
                        ctx.font = "bold 12px kathen" // Ù†ÙˆØ¹ Ø§Ù„Ø®Ø· ÙˆØ­Ø¬Ù…Ù‡
                        ctx.fontSize = '10px'; // Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·
                        ctx.fillStyle = "#f1f1f1" // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
                        ctx.textAlign = "center"; // Ù…Ø­Ø§Ø°Ø§ Ø© Ø§Ù„Ù†Øµ
                        ctx.fillText(`$${profile[getvalueof.id].credits}`, 81, 159) // Ø§Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù…ØµØ§Ø±ÙŠ
 
                        //poits
                        ctx.font = "bold 12px kathen" // Ù†
                        ctx.fontSize = '10px'; // Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·ÙˆØ¹ Ø§Ù„Ø®Ø· ÙˆØ­Ø¬Ù…Ù‡
                        ctx.fillStyle = "#f1f1f1" // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
                        ctx.textAlign = "center"; // Ù…Ø­Ø§Ø°Ø§ Ø© Ø§Ù„Ù†Øµ
                        ctx.fillText(`${profile[getvalueof.id].points}`, 221, 159) // Ø§Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù†Ù‚Ø§Ø·
 
                        //Level
                        ctx.font = "bold 27px kathen" // Ù†ÙˆØ¹ Ø§Ù„Ø®Ø· Ùˆ Ø­Ø¬Ù…Ù‡
                        ctx.fontSize = '10px'; // Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·
                        ctx.fillStyle = "#f1f1f1" // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
                        ctx.textAlign = "center"; // Ù…Ø­Ø§Ø°Ø§ Ø© Ø§Ù„Ù†Øµ
                        ctx.fillText(`${profile[getvalueof.id].level}`, 221, 118) // Ø§Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù„ÙÙ„
 
                         //info
                        ctx.font = "bold 12px kathen" // Ù†
                        ctx.fontSize = '15px'; // Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·ÙˆØ¹ Ø§Ù„Ø®Ø· ÙˆØ­Ø¬Ù…Ù‡
                        ctx.fillStyle = "#000000" // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
                        ctx.textAlign = "center"; // Ù…Ø­Ø§Ø°Ø§ Ø© Ø§Ù„Ù†Øµ
                        ctx.fillText(`${profile[getvalueof.id].tite}`, 150, 199) // Ø§Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù†Ù‚Ø§Ø·
 
                        //info
                        ctx.font = "bold 12px kathen" // Ù†
                        ctx.fontSize = '15px'; // Ø¹Ø±Ø¶ Ø§Ù„Ø®Ø·ÙˆØ¹ Ø§Ù„Ø®Ø· ÙˆØ­Ø¬Ù…Ù‡
                        ctx.fillStyle = "#f1f1f1" // Ù„ÙˆÙ† Ø§Ù„Ø®Ø·
                        ctx.textAlign = "center"; // Ù…Ø­Ø§Ø°Ø§ Ø© Ø§Ù„Ù†Øµ
                        ctx.fillText(`${profile[getvalueof.id].tite}`, 150, 197) // Ø§Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù†Ù‚Ø§Ø·
 
                        // REP
                        ctx.font = "bold 26px  kathen";
                        ctx.fontSize = "50px";
                        ctx.fillStyle = "#f1f1f1";
                        ctx.textAlign = "center";
                        ctx.fillText(`+${profile[getvalueof.id].rep}`, 80,117)
 
                        let Avatar = Canvas.Image;
                        let ava = new Avatar;
 
ava.src = buf;
                        ctx.beginPath();
                        ctx.arc(75, 100, 780, 0, Math.PI*2, true);
                        ctx.closePath();
                        ctx.clip();
                        ctx.drawImage(ava, 116, 82, 72, 72);
 
message.channel.startTyping()
message.channel.sendFile(canvas.toBuffer())
message.channel.stopTyping()
})
})
}
});
client.on('message', async msg => {
  if (msg.author.bot) return undefined;
  if (!msg.content.startsWith(prefix)) return undefined;
  const args = msg.content.split(' ');
  const searchString = args.slice(1).join(' ');
  const url = args[1] ? args[1] .replace(/<(.+)>/g, '$1') : '';
  const serverQueue = queue.get(msg.guild.id);
  let command = msg.content.toLowerCase().split(" ")[0];
  command = command.slice(prefix.length)
  if (command === `play`) {
    const voiceChannel = msg.member.voiceChannel;
    if (!voiceChannel) return msg.channel.send('ÙŠØ¬Ø¨ ØªÙˆØ¢Ø¬Ø¯ Ø­Ø¶Ø±ØªÙƒ Ø¨Ø±ÙˆÙ… ØµÙˆØªÙŠ .');
    const permissions = voiceChannel.permissionsFor(msg.client.user);
    if (!permissions.has('CONNECT')) {
      return msg.channel.send('Ù„Ø§ ÙŠØªÙˆØ¢Ø¬Ø¯ Ù„Ø¯ÙŠ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„ØªÙƒÙ„Ù… Ø¨Ù‡Ø°Ø¢ Ø§Ù„Ø±ÙˆÙ…');
    }
    if (!permissions.has('SPEAK')) {
      return msg.channel.send('Ù„Ø§ ÙŠØªÙˆØ¢Ø¬Ø¯ Ù„Ø¯ÙŠ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„ØªÙƒÙ„Ù… Ø¨Ù‡Ø°Ø¢ Ø§Ù„Ø±ÙˆÙ…');
    }

    if (!permissions.has('EMBED_LINKS')) {
      return msg.channel.sendMessage("**ÙŠØ¬Ø¨ ØªÙˆØ¢ÙØ± Ø¨Ø±Ù…Ø´Ù† `EMBED LINKS`Ù„Ø¯ÙŠ **rl")
      }

    if (url.match(/^https?:\/\/(www.youtube.com|youtube.com)\/playlist(.*)$/)) {
      const playlist = await youtube.getPlaylist(url);
      const videos = await playlist.getVideos();
      for (const video of Object.values(videos)) {
        const video2 = await youtube.getVideoByID(video.id);
        await handleVideo(video2, msg, voiceChannel, true);
      }
      return msg.channel.send(` **${playlist.title}** ØªÙ… Ø§Ù„Ø¥Ø¶Ø¢ÙØ© Ø¥Ù„Ù‰ Ù‚Ø£Ø¦Ù…Ø© Ø§Ù„ØªØ´ØºÙŠÙ„`);
    } else {
      try {

        var video = await youtube.getVideo(url);

      } catch (error) {
        try {
                          var fast = {};
          var videos = await youtube.searchVideos(searchString, 10);
          let index = 0;
          const embed1 = new Discord.RichEmbed()
              .setDescription(`**Ø§Ù„Ø±Ø¬Ø¢Ø¡ Ù…Ù† Ø­Ø¶Ø±ØªÙƒ Ø¥Ø®ØªÙŠØ¢Ø± Ø±Ù‚Ù… Ø§Ù„Ù…Ù‚Ø·Ø¹** :
${videos.map(video2 => `[**${++index}**] **${video2.title}**`).join('\n')}`)
          .setFooter(`${msg.guild.name}`)
            .setThumbnail('https://e.top4top.net/p_1001lsv3w1.png')

          msg.channel.sendEmbed(embed1).then(message =>{

            message.delete(15000)

          });
          try {
            var response = await msg.channel.awaitMessages(msg2 => msg2.content > 0 && msg2.content < 11, {
              maxMatches: 1,
              time: 20000,
              errors: ['time']
            })

            }catch(err) {
            console.error(err);
            return msg.channel.send('Ù„Ù… ÙŠØªÙ… Ø¥Ø®ØªÙŠØ¢Ø± Ù…Ù‚Ø·Ø¹ ØµÙˆØªÙŠ');
            }
          const videoIndex = parseInt(response.first().content);
          var video = await youtube.getVideoByID(videos[videoIndex - 1].id);
        } catch (err) {
          console.error(err);
          return msg.channel.send(':x: Ù„Ø§ ÙŠØªÙˆÙØ± Ù†ØªØ¢Ø¦Ø¬ Ø¨Ø­Ø« ');
        }
    }

      return handleVideo(video, msg, voiceChannel);
    }
  } else if (command === `skip`) {
    if (!msg.member.voiceChannel) return msg.channel.send('Ø£Ù†Øª Ù„Ø³Øª Ø¨Ø±ÙˆÙ… ØµÙˆØªÙŠ .');
    if (!serverQueue) return msg.channel.send('Ù„Ø§ ÙŠØªÙˆÙØ± Ù…Ù‚Ø·Ø¹ Ù„ØªØ¬Ø¢ÙˆØ²Ù‡');
    serverQueue.connection.dispatcher.end('ØªÙ… ØªØ¬Ø¢ÙˆØ² Ù‡Ø°Ø¢ Ø§Ù„Ù…Ù‚Ø·Ø¹');
    return undefined;
  } else if (command === `stop`) {
    if (!msg.member.voiceChannel) return msg.channel.send('Ø£Ù†Øª Ù„Ø³Øª Ø¨Ø±ÙˆÙ… ØµÙˆØªÙŠ .');
    if (!serverQueue) return msg.channel.send('Ù„Ø§ ÙŠØªÙˆÙØ± Ù…Ù‚Ø·Ø¹ Ù„Ø¥ÙŠÙ‚Ø¢ÙÙ‡');
    serverQueue.songs = [];
    serverQueue.connection.dispatcher.end(':cry:');
    return undefined;
  } else if (command === `vol`) {
    if (!msg.member.voiceChannel) return msg.channel.send('Ø£Ù†Øª Ù„Ø³Øª Ø¨Ø±ÙˆÙ… ØµÙˆØªÙŠ .');
    if (!serverQueue) return msg.channel.send('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø´ÙŠØ¡ Ø´ØºØ¢Ù„.');
    if (!args[1]) return msg.channel.send(`:loud_sound: Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµÙˆØª **${serverQueue.volume}**`);
    serverQueue.volume = args[1];
    serverQueue.connection.dispatcher.setVolumeLogarithmic(args[1] / 50);
    return msg.channel.send(`:speaker: ØªÙ… ØªØºÙŠØ± Ø§Ù„ØµÙˆØª Ø§Ù„ÙŠ **${args[1]}**`);
  } else if (command === `np`) {
    if (!serverQueue) return msg.channel.send('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø´ÙŠØ¡ Ø­Ø§Ù„ÙŠ Ù Ø§Ù„Ø¹Ù…Ù„.');
    const embedNP = new Discord.RichEmbed()
  .setDescription(`:notes: Ø§Ù„Ø§Ù† ÙŠØªÙ… ØªØ´ØºÙŠÙ„ : **${serverQueue.songs[0].title}**`)
    return msg.channel.sendEmbed(embedNP);
  } else if (command === `replay`) {
    if (!serverQueue) return msg.channel.send('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø´ÙŠØ¡ Ø­Ø§Ù„ÙŠ Ù Ø§Ù„Ø¹Ù…Ù„.');
    const embedNP = new Discord.RichEmbed()
  .setDescription(`Ø³ÙŠØªÙ… Ø§Ø¹Ø§Ø¯Ù‡ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙØ¯ÙŠÙˆ :**${serverQueue.songs[0].title}**`)
  msg.channel.send({embed: embedNP})
     return handleVideo(video, msg, msg.member.voiceChannel);

  } else if (command === `queue`) {
    if (!serverQueue) return msg.channel.send('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø´ÙŠØ¡ Ø­Ø§Ù„ÙŠ Ù Ø§Ù„Ø¹Ù…Ù„.');
    let index = 0;
    const embedqu = new Discord.RichEmbed()
.setDescription(`**Songs Queue**
${serverQueue.songs.map(song => `**${++index} -** ${song.title}`).join('\n')}
**Ø§Ù„Ø§Ù† ÙŠØªÙ… ØªØ´ØºÙŠÙ„** ${serverQueue.songs[0].title}`)
    return msg.channel.sendEmbed(embedqu);
  } else if (command === `pause`) {
    if (serverQueue && serverQueue.playing) {
      serverQueue.playing = false;
      serverQueue.connection.dispatcher.pause();
      return msg.channel.send('ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ù…Ø¤Ù‚ØªØ§!');
    }
    return msg.channel.send('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø´ÙŠØ¡ Ø­Ø§Ù„ÙŠ Ù Ø§Ù„Ø¹Ù…Ù„.');
  } else if (command === "resume") {
    if (serverQueue && !serverQueue.playing) {
      serverQueue.playing = true;
      serverQueue.connection.dispatcher.resume();
      return msg.channel.send('Ø§Ø³ØªØ£Ù†ÙØª Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ùƒ !');
    }
    return msg.channel.send('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø´ÙŠØ¡ Ø­Ø§Ù„ÙŠ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„.');
  }

  return undefined;
async function handleVideo(video, msg, voiceChannel, playlist = false) {
  const serverQueue = queue.get(msg.guild.id);
  const song = {
    id: video.id,
    title: Util.escapeMarkdown(video.title),
    url: `https://www.youtube.com/watch?v=${video.id}`,
    time:`${video.duration.hours}:${video.duration.minutes}:${video.duration.seconds}`,
    eyad:`${video.thumbnails.high.url}`,
    best:`${video.channel.title}`,
    bees:`${video.raw.snippet.publishedAt}`,
    shahd:`${video.raw.kind}`,
    zg:`${video.raw.snippet.channelId}`,
        views:`${video.raw.views}`,
        like:`${video.raw.likeCount}`,
        dislike:`${video.raw.dislikeCount}`,
        hi:`${video.raw.id}`
  };
  if (!serverQueue) {
    const queueConstruct = {
      textChannel: msg.channel,
      voiceChannel: voiceChannel,
      connection: null,
      songs: [],
      volume: 5,
      playing: true
    };
    queue.set(msg.guild.id, queueConstruct);
    queueConstruct.songs.push(song);
    try {
      var connection = await voiceChannel.join();
      queueConstruct.connection = connection;
      play(msg.guild, queueConstruct.songs[0]);
    } catch (error) {
      console.error(`I could not join the voice channel: ${error}`);
      queue.delete(msg.guild.id);
      return msg.channel.send(`Ù„Ø§ Ø£Ø³ØªØ·ÙŠØ¹ Ø¯Ø®ÙˆÙ„ Ù‡Ø°Ø¢ Ø§Ù„Ø±ÙˆÙ… ${error}`);
    }
  } else {
    serverQueue.songs.push(song);
    console.log(serverQueue.songs);
    if (playlist) return undefined;
    else return msg.channel.send(` **${song.title}** ØªÙ… Ø§Ø¶Ø§ÙÙ‡ Ø§Ù„Ø§ØºÙ†ÙŠØ© Ø§Ù„ÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©!`);
  }
  return undefined;
}

function play(guild, song) {
  const serverQueue = queue.get(guild.id);

  if (!song) {
    serverQueue.voiceChannel.leave();
    queue.delete(guild.id);
    return;
  }
  console.log(serverQueue.songs);
  const dispatcher = serverQueue.connection.playStream(ytdl(song.url))
    .on('end', reason => {
      if (reason === 'Stream is not generating quickly enough.') console.log('Song ended.');
      else console.log(reason);
      serverQueue.songs.shift();
      play(guild, serverQueue.songs[0]);
    })
    .on('error', error => console.error(error));
  dispatcher.setVolumeLogarithmic(serverQueue.volume / 5);
    fetchVideoInfo(`${song.hi}`, function (err,  idk) {
  if (err) throw new Error(err);
  console.log( idk);
      const yyyy = {}
  if(!yyyy[msg.guild.id]) yyyy[msg.guild.id] = {
    like: `${ idk.likeCount}`,
    dislike: `${ idk.dislikeCount}`
  }
  serverQueue.textChannel.send({embed : new Discord.RichEmbed()
  .setTitle(`**${ idk.title}**`)
  .setURL( idk.url)
  .addField('Time The Video :' , `${song.time}`, true)
  .addField('Channel Name :' , `${song.best}`, true)
  .addField('Channel ID :' , `${song.zg}`, true)
  .addField('Video Created at :' , `${ idk.datePublished}`, true)
  .addField('Views :' , `${ idk.views}`, true)
  .addField('LikeğŸ‘ :' , `${ idk.likeCount}`, true)
  .addField('dislikeğŸ‘ :' , `${ idk.dislikeCount}`, true)
  .addField('comments :' , `${ idk.commentCount}`, true)
  .setImage(`${song.eyad}`)
  .setThumbnail('http://cdn.akhbaar24.com/430e061a-f89a-43c7-86d9-82fae5f7c495.jpg')
  .setColor('#ff0000')
  .setTimestamp()
  }).then(love => {
    love.react('ğŸ‘').then(r=>{
    love.react('ğŸ‘').then(r =>{
    love.react('ğŸ™Œ').then(r=> {
    let likee = (reaction, user) => reaction.emoji.name === 'ğŸ‘' && user.id === msg.author.id;
    let dislikee = (reaction, user) => reaction.emoji.name === 'ğŸ‘' && user.id === msg.author.id;
    let cnn = (reaction, user) => reaction.emoji.name === 'ğŸ™Œ' && user.id === msg.author.id;

    let ll = love.createReactionCollector(likee , {max:5});
    let dd = love.createReactionCollector(dislikee , {max:5});
    let cn = love.createReactionCollector(cnn , {max:5});

        ll.on("collect", r => {
          yyyy[msg.guild.id].like++;
  love.edit({embed : new Discord.RichEmbed()
  .setTitle(`**${ idk.title}**`)
  .setURL( idk.url)
  .addField('Time The Video :' , `${song.time}`, true)
  .addField('Channel Name :' , `${song.best}`, true)
  .addField('Channel ID :' , `${song.zg}`, true)
  .addField('Video Created at :' , `${ idk.datePublished}`, true)
  .addField('Views :' , `${ idk.views}`, true)
  .addField('LikeğŸ‘ :' , `${yyyy[msg.guild.id].like}`, true)
  .addField('dislikeğŸ‘ :' , `${ idk.dislikeCount}`, true)
  .addField('comments :' , `${ idk.commentCount}`, true)
  .setImage(`${song.eyad}`)
  .setThumbnail('http://cdn.akhbaar24.com/430e061a-f89a-43c7-86d9-82fae5f7c495.jpg')
  .setColor('#ff0000')
  .setTimestamp()
});
    })

    dd.on("collect", r => {
      yyyy[msg.guild.id].dislike++;
  love.edit({embed : new Discord.RichEmbed()
  .setTitle(`**${ idk.title}**`)
  .setURL( idk.url)
  .addField('Time The Video :' , `${song.time}`, true)
  .addField('Channel Name :' , `${song.best}`, true)
  .addField('Channel ID :' , `${song.zg}`, true)
  .addField('Video Created at :' , `${ idk.datePublished}`, true)
  .addField('Views :' , `${ idk.views}`, true)
  .addField('LikeğŸ‘ :' , `${ idk.likeCount}`, true)
  .addField('dislikeğŸ‘ :' , `${yyyy[msg.guild.id].dislike}`, true)
  .addField('comments :' , `${ idk.commentCount}`, true)
  .setImage(`${song.eyad}`)
  .setThumbnail('http://cdn.akhbaar24.com/430e061a-f89a-43c7-86d9-82fae5f7c495.jpg')
  .setColor('#ff0000')
  .setTimestamp()
});
})
    cn.on("collect", r => {
  love.edit({embed : new Discord.RichEmbed()
  .setTitle(`**${ idk.title}**`)
  .setURL( idk.url)
  .addField('Time The Video :' , `${song.time}`, true)
  .addField('Channel Name :' , `${song.best}`, true)
  .addField('Channel ID :' , `${song.zg}`, true)
  .addField('Video Created at :' , `${ idk.datePublished}`, true)
  .addField('Views :' , `${ idk.views}`, true)
  .addField('LikeğŸ‘ :' , `${ idk.likeCount}`, true)
  .addField('dislikeğŸ‘ :' , `${ idk.dislikeCount}`, true)
  .addField('comments :' , `${ idk.commentCount}`, true)
  .setImage(`${song.eyad}`)
  .setThumbnail('http://cdn.akhbaar24.com/430e061a-f89a-43c7-86d9-82fae5f7c495.jpg')
  .setColor('#ff0000')
  .setTimestamp()
});
})
})
})
})
})
})
}
});
let ar = JSON.parse(fs.readFileSync(`./Data/AutoRole.json`, `utf8`))
client.on('guildMemberAdd', member => {
if(!ar[member.guild.id]) ar[member.guild.id] = {
onoff: 'Off',
role: 'Member'
}
if(ar[member.guild.id].onoff === 'Off') return;
member.addRole(member.guild.roles.find(`name`, ar[member.guild.id].role)).catch(console.error)
})
client.on('message', message => {
if(!message.guild) return
if(!ar[message.guild.id]) ar[message.guild.id] = {
onoff: 'Off',
role: 'Member'
}
if(message.content.startsWith(prefix + `autorole`)) {
let perms = message.member.hasPermission(`MANAGE_ROLES`)
if(!perms) return message.reply(`You don't have permissions, required permission : Manage Roles.`)
let args = message.content.split(" ").slice(1)
if(!args.join(" ")) return message.reply(`${prefix}autorle toggle/autoset [ROLE NAME]`)
let state = args[0]
if(!state.trim().toLowerCase() == 'toggle' || !state.trim().toLowerCase() == 'setrole') return message.reply(`Please type a right state, ${prefix}modlogs toggle/setrole [ROLE NAME]`)
if(state.trim().toLowerCase() == 'toggle') {
if(ar[message.guild.id].onoff === 'Off') return [message.channel.send(`**The Autorole Is __ğğ__ !**`), ar[message.guild.id].onoff = 'On']
if(ar[message.guild.id].onoff === 'On') return [message.channel.send(`**The Autorole Is __ğğ…ğ…__ !**`), ar[message.guild.id].onoff = 'Off']
}
if(state.trim().toLowerCase() == 'autoset') {
let newRole = message.content.split(" ").slice(2).join(" ")
if(!newRole) return message.reply(`${prefix}autorole setrole [ROLE NAME]`)
if(!message.guild.roles.find(`name`,newRole)) return message.reply(`I Cant Find This Role.`)
ar[message.guild.id].role = newRole
message.channel.send(`**The AutoRole Has Been Changed to ${newRole}.**`)
}
  }
if(message.content === prefix + 'autoroleinfo') {
let perms = message.member.hasPermission(`MANAGE_GUILD`)
if(!perms) return message.reply(`You don't have permissions.`)
var embed = new Discord.RichEmbed()
.addField(`Autorole : :sparkles:  `, `
State : __${ar[message.guild.id].onoff}__
Role : __${ar[message.guild.id].role}__`)
.setColor(`BLUE`)
message.channel.send({embed})
}
fs.writeFile("./Data/AutoRole.json", JSON.stringify(ar), (err) => {
if (err) console.error(err)
});
})
const welcome = JSON.parse(fs.readFileSync('./welcomer.json' , 'utf8'));
client.on('message', async message => {
    let messageArray = message.content.split(" ");
   if(message.content.startsWith(prefix + "sl")) {
             
    let filter = m => m.author.id === message.author.id;
    let thisMessage;
    let thisFalse;

    if(!message.member.hasPermission("MANAGE_GUILD")) return message.channel.send('You don\'t have permission').then(msg => {
       msg.delete(4500);
       message.delete(4500);
    });
    
    message.channel.send(':pencil: **| Ù…Ù† ÙØ¶Ù„Ùƒ Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø³Ø§Ù„Ù‡ Ø§Ù„Ø§Ù†... :pencil2: **').then(msg => {

        message.channel.awaitMessages(filter, {
          max: 1,
          time: 90000,
          errors: ['time']
        })
        .then(collected => {
            collected.first().delete();
            thisMessage = collected.first().content;
            let boi;
            msg.edit(':scroll: **| Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„Ø§Ù†... :pencil2: **').then(msg => {
      
                message.channel.awaitMessages(filter, {
                  max: 1,
                  time: 90000,
                  errors: ['time']
                })
                .then(collected => {
                    collected.first().delete();
                    boi = collected.first().content;
                    msg.edit('âœ… **| ØªÙ… Ø§Ù„Ø§Ø¹Ø¯Ø§Ø¯ Ø¨Ù†Ø¬Ø§Ø­...  **').then(msg => {
        
                      message.channel.awaitMessages(filter, {
                        max: 1,
                        time: 90000,
                        errors: ['time']
                      })
                      let embed = new Discord.RichEmbed()
                      .setTitle('**Done The Leave Msg Code Has Been Setup**')
                      .addField('Message:', `${thisMessage}`)
                      .addField('Channel:', `${boi}`)
                      .setThumbnail(message.author.avatarURL)
                      .setFooter(`${client.user.username}`)
                     message.channel.sendEmbed(embed)
    welcome[message.guild.id] = {
leavechannel: boi,
leavemsg: thisMessage,
onoff: 'On',
leave: 'On'
    }
    fs.writeFile("./welcomer.json", JSON.stringify(welcome), (err) => {
    if (err) console.error(err)
  })
   } 
            )
        })
    })
})
    })
}})
client.on('message', message => {
           if (!message.channel.guild) return;

    let room = message.content.split(" ").slice(1);
    let findroom = message.guild.channels.find('name', `${room}`)
    if(message.content.startsWith(prefix + "setWelcomeØ«Ø«Ø«Ù‚Ø¶Ø¶ØµÙ‚r")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
if(!room) return message.channel.send('Please Type The Channel Name')
if(!findroom) return message.channel.send('Cant Find This Channel')
let embed = new Discord.RichEmbed()
.setTitle('**Done The Welcome Code Has Been Setup**')
.addField('Channel:', `${room}`)
.addField('Requested By:', `${message.author}`)
.setThumbnail(message.author.avatarURL)
.setFooter(`${client.user.username}`)
message.channel.sendEmbed(embed)
welcome[message.guild.id] = {
channel: room,
onoff: 'On',
by: 'On',
dm: 'Off',
leave: 'Off'
}
fs.writeFile("./welcomer.json", JSON.stringify(welcome), (err) => {
if (err) console.error(err)
})
    }})
            client.on('message', message => {
  
    if(message.content.startsWith(prefix + "togl")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
        if(!welcome[message.guild.id]) welcome[message.guild.id] = {
            onoff: 'Off',
          leave: 'Off'
        }
          if(welcome[message.guild.id].leave === 'Off') return [message.channel.send(`**The Leave Msg Is __ğğ__ !**`), welcome[message.guild.id].leave = 'On']
          if(welcome[message.guild.id].leave === 'On') return [message.channel.send(`**The Leave Msg Is __ğğ…ğ…__ !**`), welcome[message.guild.id].leave = 'Off']
          fs.writeFile("./welcome.json", JSON.stringify(welcome), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            })
          }
          
        })
        client.on('message', message => {
  
    if(message.content.startsWith(prefix + "togdmwlc")) {
        if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
        if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
        if(!welcome[message.guild.id]) welcome[message.guild.id] = {
          dm: 'Off'
        }
          if(welcome[message.guild.id].dm === 'Off') return [message.channel.send(`**The Welcome Dm Is __ğğ__ !**`), welcome[message.guild.id].dm = 'On']
          if(welcome[message.guild.id].dm === 'On') return [message.channel.send(`**The Welcome Dm Is __ğğ…ğ…__ !**`), welcome[message.guild.id].dm = 'Off']
          fs.writeFile("./welcome.json", JSON.stringify(welcome), (err) => {
            if (err) console.error(err)
            .catch(err => {
              console.error(err);
          });
            })
          }
          
        })
        client.on('message', message => {
  
            if(message.content.startsWith(prefix + "toginv")) {
                if(!message.channel.guild) return message.reply('**This Command Only For Servers**');
                if(!message.member.hasPermission('MANAGE_GUILD')) return message.channel.send('**Sorry But You Dont Have Permission** `MANAGE_GUILD`' );
                if(!welcome[message.guild.id]) welcome[message.guild.id] = {
                  by: 'Off'
                }
                  if(welcome[message.guild.id].by === 'Off') return [message.channel.send(`**The Invited By Is __ğğ__ !**`), welcome[message.guild.id].by = 'On']
                  if(welcome[message.guild.id].by === 'On') return [message.channel.send(`**The Invited By Is __ğğ…ğ…__ !**`), welcome[message.guild.id].by = 'Off']
                  fs.writeFile("./welcome.json", JSON.stringify(welcome), (err) => {
                    if (err) console.error(err)
                    .catch(err => {
                      console.error(err);
                  });
                    })
                  }
                  
                })
      client.on("guildMemberRemove", member => {
            if(!welcome[member.guild.id]) welcome[member.guild.id] = {
          onoff: 'Off',
          leave: 'Off'
        }
        
        if(welcome[member.guild.id].onoff === 'Off') return;
                if(welcome[member.guild.id].leave === 'Off') return;
    let welcomer = member.guild.channels.find('name', `${welcome[member.guild.id].leavechannel}`)
    if(!welcomer) return;
     welcomer.send(`${member} ${welcome[member.guild.id].leavemsg}`);
      })          

client.on("guildMemberAdd", member => {
            if(!welcome[member.guild.id]) welcome[member.guild.id] = {
          onoff: 'Off'
        }
        if(welcome[member.guild.id].onoff === 'Off') return;
    let welcomer = member.guild.channels.find('name', `${welcome[member.guild.id].channel}`)
    let memberavatar = member.user.avatarURL
      if (!welcomer) return;
      if(welcomer) {
         moment.locale('ar-ly');
         var h = member.user;
        let heroo = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setThumbnail(h.avatarURL)
        .setAuthor(h.username,h.avatarURL)
        .addField(': ØªØ§Ø±ÙŠØ® Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø¯Ø³ÙƒÙˆØ±Ø¯',`${moment(member.user.createdAt).format('D/M/YYYY h:mm a')} **\n** \`${moment(member.user.createdAt).fromNow()}\``,true)
         .setFooter(`${h.tag}`,"https://images-ext-2.discordapp.net/external/JpyzxW2wMRG2874gSTdNTpC_q9AHl8x8V4SMmtRtlVk/https/orcid.org/sites/default/files/files/ID_symbol_B-W_128x128.gif")
     welcomer.send({embed:heroo});
      }})



client.on('guildMemberAdd',async member => {
            if(!welcome[member.guild.id]) welcome[member.guild.id] = {
          onoff: 'Off'
        }
    if(welcome[member.guild.id].onoff === 'Off') return;
    const Canvas = require('canvas');
    const jimp = require('jimp');
    const w = ['./welcome_4.png'];
          let Image = Canvas.Image,
              canvas = new Canvas.Canvas(800, 300),
              ctx = canvas.getContext('2d');
          ctx.patternQuality = 'bilinear';
          ctx.filter = 'bilinear';
          ctx.antialias = 'subpixel';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
          ctx.shadowOffsetY = 2;
          ctx.shadowBlur = 2;
          ctx.stroke();
          ctx.beginPath();
   
          fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
              if (err) return console.log(err);
              let BG = Canvas.Image;
              let ground = new Image;
              ground.src = Background;
              ctx.drawImage(ground, 0, 0, 800, 300);
   
  })
   
                  let url = member.user.displayAvatarURL.endsWith(".webp") ? member.user.displayAvatarURL.slice(5, -20) + ".png" : member.user.displayAvatarURL;
                  jimp.read(url, (err, ava) => {
                      if (err) return console.log(err);
                      ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                   if (err) return console.log(err);
   
            ctx.font = '36px Arial';
            ctx.fontSize = '72px';
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.fillText(member.user.username, 545, 177);
           
            ctx.font = '16px Arial Bold';
            ctx.fontSize = '72px';
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.fillText(`Your The Member ${member.guild.memberCount}`, 580, 200);
           
            let Avatar = Canvas.Image;
            let ava = new Avatar;
            ava.src = buf;
            ctx.beginPath();
            ctx.arc(169.5, 148, 126.9, -100, Math.PI * 2, true);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(ava, 36, 21, 260, 260);
             
            let c = member.guild.channels.find('name', `${welcome[member.guild.id].channel}`)
            if(!c) return;
            c.sendFile(canvas.toBuffer());
   
  });
  });
  });

  const invites = {};

const wait = require('util').promisify(setTimeout);

client.on('ready', () => {
  wait(1000);

  client.guilds.forEach(g => {
    g.fetchInvites().then(guildInvites => {
      invites[g.id] = guildInvites;
    });
  });
});

client.on('guildMemberAdd', member => {
                    if(!welcome[member.guild.id]) welcome[member.guild.id] = {
                  by: 'Off'
                }
    if(welcome[member.guild.id].by === 'Off') return;
  member.guild.fetchInvites().then(guildInvites => {
    const ei = invites[member.guild.id];
    invites[member.guild.id] = guildInvites;
    const invite = guildInvites.find(i => ei.get(i.code).uses < i.uses);
    const inviter = client.users.get(invite.inviter.id);
    const logChannel = member.guild.channels.find(channel => channel.name === `${welcome[member.guild.id].channel}`);
    if(!logChannel) return;
      setTimeout(() => {
    logChannel.send(`Invited By: <@${inviter.id}>`);
  },2000)
  });
});

client.on("guildMemberAdd", member => {
                    if(!welcome[member.guild.id]) welcome[member.guild.id] = {
                  dm: 'Off'
                }
        if(welcome[member.guild.id].dm === 'Off') return;
  member.createDM().then(function (channel) {
  return channel.send(`:rose:  ÙˆÙ„ÙƒÙ… Ù†ÙˆØ±Øª Ø§Ù„Ø³ÙŠØ±ÙØ±:rose: 
:crown:Ø§Ø³Ù… Ø§Ù„Ø¹Ø¶Ùˆ  ${member}:crown:  
Ø§Ù†Øª Ø§Ù„Ø¹Ø¶Ùˆ Ø±Ù‚Ù… ${member.guild.memberCount} `) 
}).catch(console.error)
})
client.login('');